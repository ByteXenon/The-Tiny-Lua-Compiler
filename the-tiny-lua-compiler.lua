--[[

TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE
T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E
T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E
T:::::TT:::::::TT:::::THH::::::H     H::::::HHEE::::::EEEEEEEEE::::E
TTTTTT  T:::::T  TTTTTT  H:::::H     H:::::H    E:::::E       EEEEEE
        T:::::T          H:::::H     H:::::H    E:::::E
        T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE
        T:::::T          H:::::::::::::::::H    E:::::::::::::::E
        T:::::T          H:::::::::::::::::H    E:::::::::::::::E
        T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE
        T:::::T          H:::::H     H:::::H    E:::::E
        T:::::T          H:::::H     H:::::H    E:::::E       EEEEEE
      TT:::::::TT      HH::::::H     H::::::HHEE::::::EEEEEEEE:::::E
      T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E
      T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E
      TTTTTTTTTTT      HHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE

TTTTTTTTTTTTTTTTTTTTTTTIIIIIIIIIINNNNNNNN        NNNNNNNNYYYYYYY       YYYYYYY
T:::::::::::::::::::::TI::::::::IN:::::::N       N::::::NY:::::Y       Y:::::Y
T:::::::::::::::::::::TI::::::::IN::::::::N      N::::::NY:::::Y       Y:::::Y
T:::::TT:::::::TT:::::TII::::::IIN:::::::::N     N::::::NY::::::Y     Y::::::Y
TTTTTT  T:::::T  TTTTTT  I::::I  N::::::::::N    N::::::NYYY:::::Y   Y:::::YYY
        T:::::T          I::::I  N:::::::::::N   N::::::N   Y:::::Y Y:::::Y
        T:::::T          I::::I  N:::::::N::::N  N::::::N    Y:::::Y:::::Y
        T:::::T          I::::I  N::::::N N::::N N::::::N     Y:::::::::Y
        T:::::T          I::::I  N::::::N  N::::N:::::::N      Y:::::::Y
        T:::::T          I::::I  N::::::N   N:::::::::::N       Y:::::Y
        T:::::T          I::::I  N::::::N    N::::::::::N       Y:::::Y
        T:::::T          I::::I  N::::::N     N:::::::::N       Y:::::Y
      TT:::::::TT      II::::::IIN::::::N      N::::::::N       Y:::::Y
      T:::::::::T      I::::::::IN::::::N       N:::::::N    YYYY:::::YYYY
      T:::::::::T      I::::::::IN::::::N        N::::::N    Y:::::::::::Y
      TTTTTTTTTTT      IIIIIIIIIINNNNNNNN         NNNNNNN    YYYYYYYYYYYYY

 LLLLLLLLLLL            UUUUUUUU     UUUUUUUU           AAA
 L:::::::::L            U::::::U     U::::::U          A:::A
 L:::::::::L            U::::::U     U::::::U         A:::::A
 LL:::::::LL            UU:::::U     U:::::UU        A:::::::A
   L:::::L               U:::::U     U:::::U        A:::::::::A
   L:::::L               U:::::D     D:::::U       A:::::A:::::A
   L:::::L               U:::::D     D:::::U      A:::::A A:::::A
   L:::::L               U:::::D     D:::::U     A:::::A   A:::::A
   L:::::L               U:::::D     D:::::U    A:::::A     A:::::A
   L:::::L               U:::::D     D:::::U   A:::::AAAAAAAAA:::::A
   L:::::L               U:::::D     D:::::U  A:::::::::::::::::::::A
   L:::::L         LLLLLLU::::::U   U::::::U A:::::AAAAAAAAAAAAA:::::A
 LL:::::::LLLLLLLLL:::::LU:::::::UUU:::::::UA:::::A             A:::::A
 L::::::::::::::::::::::L UU:::::::::::::UUA:::::A               A:::::A
 L::::::::::::::::::::::L   UU:::::::::UU A:::::A                 A:::::A
 LLLLLLLLLLLLLLLLLLLLLLLL     UUUUUUUUU  AAAAAAA                   AAAAAAA

        CCCCCCCCCCCCC     OOOOOOOOO     MMMMMMMM               MMMMMMMMPPPPPPPPPPPPPPPPP   IIIIIIIIIILLLLLLLLLLL             EEEEEEEEEEEEEEEEEEEEEERRRRRRRRRRRRRRRRR
     CCC::::::::::::C   OO:::::::::OO   M:::::::M             M:::::::MP::::::::::::::::P  I::::::::IL:::::::::L             E::::::::::::::::::::ER::::::::::::::::R
   CC:::::::::::::::C OO:::::::::::::OO M::::::::M           M::::::::MP::::::PPPPPP:::::P I::::::::IL:::::::::L             E::::::::::::::::::::ER::::::RRRRRR:::::R
  C:::::CCCCCCCC::::CO:::::::OOO:::::::OM:::::::::M         M:::::::::MPP:::::P     P:::::PII::::::IILL:::::::LL             EE::::::EEEEEEEEE::::ERR:::::R     R:::::R
 C:::::C       CCCCCCO::::::O   O::::::OM::::::::::M       M::::::::::M  P::::P     P:::::P  I::::I    L:::::L                 E:::::E       EEEEEE  R::::R     R:::::R
C:::::C              O:::::O     O:::::OM:::::::::::M     M:::::::::::M  P::::P     P:::::P  I::::I    L:::::L                 E:::::E               R::::R     R:::::R
C:::::C              O:::::O     O:::::OM:::::::M::::M   M::::M:::::::M  P::::PPPPPP:::::P   I::::I    L:::::L                 E::::::EEEEEEEEEE     R::::RRRRRR:::::R
C:::::C              O:::::O     O:::::OM::::::M M::::M M::::M M::::::M  P:::::::::::::PP    I::::I    L:::::L                 E:::::::::::::::E     R:::::::::::::RR
C:::::C              O:::::O     O:::::OM::::::M  M::::M::::M  M::::::M  P::::PPPPPPPPP      I::::I    L:::::L                 E:::::::::::::::E     R::::RRRRRR:::::R
C:::::C              O:::::O     O:::::OM::::::M   M:::::::M   M::::::M  P::::P              I::::I    L:::::L                 E::::::EEEEEEEEEE     R::::R     R:::::R
C:::::C              O:::::O     O:::::OM::::::M    M:::::M    M::::::M  P::::P              I::::I    L:::::L                 E:::::E               R::::R     R:::::R
 C:::::C       CCCCCCO::::::O   O::::::OM::::::M     MMMMM     M::::::M  P::::P              I::::I    L:::::L         LLLLLL  E:::::E       EEEEEE  R::::R     R:::::R
  C:::::CCCCCCCC::::CO:::::::OOO:::::::OM::::::M               M::::::MPP::::::PP          II::::::IILL:::::::LLLLLLLLL:::::LEE::::::EEEEEEEE:::::ERR:::::R     R:::::R
   CC:::::::::::::::C OO:::::::::::::OO M::::::M               M::::::MP::::::::P          I::::::::IL::::::::::::::::::::::LE::::::::::::::::::::ER::::::R     R:::::R
     CCC::::::::::::C   OO:::::::::OO   M::::::M               M::::::MP::::::::P          I::::::::IL::::::::::::::::::::::LE::::::::::::::::::::ER::::::R     R:::::R
        CCCCCCCCCCCCC     OOOOOOOOO     MMMMMMMM               MMMMMMMMPPPPPPPPPP          IIIIIIIIIILLLLLLLLLLLLLLLLLLLLLLLLEEEEEEEEEEEEEEEEEEEEEERRRRRRRR     RRRRRRR

]]

local function createLookupTable(list)
  local lookup = {}
  for _, value in ipairs(list) do
    lookup[value] = true
  end
  return lookup
end
local function makeTrie(table)
  local trieTable = {}
  local longestElement = 0

  for _, op in ipairs(table) do
    if #op > longestElement then
      longestElement = #op
    end

    local node = trieTable
    for index = 1, #op do
      local character = op:sub(index, index)
      node[character] = node[character] or {}
      node = node[character]
    end
    node.Value = op
  end
  return trieTable, longestElement
end

--/// Tokenizer ///--
local TOKENIZER_LUA_CONSTANTS = { "true", "false", "nil" }
local TOKENIZER_LUA_OPERATORS = {
  "^", "*", "/", "%",
  "+", "-", "<", ">",
  "#",

  "<=",  ">=", "==",  "~=",
  "and", "or", "not", ".."
}
local TOKENIZER_ESCAPED_CHARACTER_CONVERSIONS = {
  ["a"]     = "\a", -- bell
  ["b"]     = "\b", -- backspace
  ["f"]     = "\f", -- form feed
  ["n"]     = "\n", -- newline
  ["r"]     = "\r", -- carriage return
  ["t"]     = "\t", -- horizontal tab
  ["v"]     = "\v", -- vertical tab

  [ "\\" ] = "\\",   -- backslash
  [ "\"" ] = "\"",  -- double quote
  [ "\'" ] = "\'",  -- single quote
}
local TOKENIZER_RESERVED_KEYWORDS = { "while",    "do",     "end",   "for",
                                      "local",    "repeat", "until", "return",
                                      "in",       "if",     "else",  "elseif",
                                      "function", "then",   "break", "continue" }

local TOKENIZER_LUA_CONSTANTS_LOOKUP     = createLookupTable(TOKENIZER_LUA_CONSTANTS)
local TOKENIZER_LUA_OPERATORS_LOOKUP     = createLookupTable(TOKENIZER_LUA_OPERATORS)
local TOKENIZER_RESERVED_KEYWORDS_LOOKUP = createLookupTable(TOKENIZER_RESERVED_KEYWORDS)

local TOKENIZER_OPERATOR_TRIE, TOKENIZER_OPERATOR_LONGEST = makeTrie(TOKENIZER_LUA_OPERATORS)

--* Tokenizer *--
local Tokenizer = {}
function Tokenizer.tokenize(code)
  local charStream, charStreamLen = {}, 0
  for char in code:gmatch(".") do
    charStreamLen = charStreamLen + 1
    charStream[charStreamLen] = char
  end

  local charStream = charStream
  local curCharPos = 1
  local curChar = charStream[curCharPos]

  --// CHARACTER NAVIGATION //--
  local function lookAhead(n)
    local updatedCharPos = curCharPos + (n or 1)
    local updatedChar    = charStream[updatedCharPos] or "\0"
    return updatedChar
  end
  local function consume(n)
    local updatedCharPos = curCharPos + (n or 1)
    local updatedChar    = charStream[updatedCharPos] or "\0"
    curCharPos = updatedCharPos
    curChar    = updatedChar
    return updatedChar
  end

  --// CHECKERS //--
  local function isWhitespace(char)
    local char = char or curChar
    return char:match("%s")
  end
  local function isNumberStart(char)
    local char = char or curChar
    return char:match("%d")
  end
  local function isNumber(char)
    local char = char or curChar
    return char:match("%d")
  end
  local function isIdentifier(char)
    local char = char or curChar
    return char:match("[%a%d_]")
  end
  local function isIdentifierStart(char)
    local char = char or curChar
    return char:match("[%a_]")
  end
  local function isScientificNotationPrefix(char)
    local char = char or curChar
    return char == "e" or char == "E"
  end
  local function isHexadecimalNumberPrefix()
    return curChar == "0" and (lookAhead() == "x" or lookAhead() == "X")
  end
  local function isVarArg()
    return curChar == "." and lookAhead(1) == "." and lookAhead(2) == "."
  end
  local function isComment()
    return curChar == "-" and lookAhead(1) == "-"
  end
  local function isString()
    return curChar == '"' or curChar == "'"
  end

  --// CONSUMERS //--
  local function consumeWhitespace()
    local whitespace = { curChar }
    while isWhitespace(lookAhead()) do
      table.insert(whitespace, curChar)
      consume()
    end
    return table.concat(whitespace)
  end
  local function consumeIdentifier()
    local identifier = { curChar }
    while isIdentifier(lookAhead()) do
      table.insert(identifier, consume())
    end
    return table.concat(identifier)
  end
  local function consumeInteger(maxLength)
    local integer = { curChar }
    while lookAhead():match("%d") do
      if (maxLength and #integer >= maxLength) then break end
      table.insert(integer, consume())
    end
    return table.concat(integer)
  end
  local function consumeNumber()
    local number = { curChar }

    -- Hexadecimal number case
    if isHexadecimalNumberPrefix() then
      table.insert(number, consume()) -- Consume the "0"
      table.insert(number, consume()) -- Consume the "x"
      while isNumber(lookAhead()) or lookAhead():match("[a-fA-F]") do
        table.insert(number, consume())
      end
      return table.concat(number)
    end

    while isNumber(lookAhead()) do
      table.insert(number, consume())
    end

    -- Floating point number case
    if lookAhead() == "." then
      table.insert(number, consume()) -- Consume the "."
      while isNumber(lookAhead()) do
        table.insert(number, consume())
      end
    end

    -- Exponential (scientific) notation case
    if isScientificNotationPrefix(lookAhead()) then
      table.insert(number, consume()) -- Consume the "e" or "E"
      if lookAhead() == "+" or lookAhead() == "-" then -- Consume optional sign
        table.insert(number, consume())
      end
      while isNumber(lookAhead()) do
        table.insert(number, consume())
      end
    end

    return table.concat(number)
  end
  local function consumeString()
    local delimiter = curChar
    local newString = { }
    consume()
    while curChar ~= delimiter do
      if curChar == "\\" then
        local nextChar = consume()
        if nextChar:match("%d") then -- Numeric escape sequence?
          local number = consumeInteger(3)
          table.insert(newString, string.char(tonumber(number)))
        elseif TOKENIZER_ESCAPED_CHARACTER_CONVERSIONS[nextChar] then
          table.insert(newString, TOKENIZER_ESCAPED_CHARACTER_CONVERSIONS[nextChar])
        else
          error("invalid escape sequence near '\\" .. nextChar .. "'")
        end
      else
        table.insert(newString, curChar)
      end
      consume()
    end
    return table.concat(newString)
  end
  local function consumeOperator()
    local node = TOKENIZER_OPERATOR_TRIE
    local operator

    for index = 0, TOKENIZER_OPERATOR_LONGEST - 1 do
      local character = lookAhead(index)
      node = node[character]
      if not node then break end
      if node.Value then operator = node.Value end
    end
    if operator then consume(#operator - 1) end
    return operator
  end
  local function consumeShortComment()
    while curChar ~= "\0" and curChar ~= "\n" do
      consume()
    end
  end
  local function consumeLongComment()
    consume() -- Consumes the "[" character
    local depth = 0
    while curChar == "=" do
      consume() -- Consume the "=" character
      depth = depth + 1
    end
    if curChar ~= "[" then return consumeShortComment() end
    while true do
      if curChar == "]" then
        consume() -- Consume the "]" character
        local closingDepth = 0
        while curChar == "=" do
          consume() -- Consume the "=" character
          closingDepth = closingDepth + 1
        end
        if closingDepth == depth then break end
      elseif curChar == "\0" then
        error("Unclosed long comment")
      else
        consume()
      end
    end
  end
  local function consumeComment()
    consume() -- Consume the "-" character
    consume() -- Consume the "-" character
    if curChar == "[" then
      return consumeLongComment()
    end
    return consumeShortComment()
  end

  --// TOKENIZERS //--
  local function getNextToken()
    local curChar = curChar
    if isWhitespace(curChar) then
      consumeWhitespace()
      return
    elseif isComment() then
      consumeComment()
      return
    elseif isNumberStart(curChar) then
      return { TYPE = "Number", Value = tonumber(consumeNumber()) }
    elseif isIdentifierStart(curChar) then
      local identifier = consumeIdentifier()
      if TOKENIZER_LUA_OPERATORS_LOOKUP[identifier] then
        return { TYPE = "Operator", Value = identifier }
      elseif TOKENIZER_RESERVED_KEYWORDS_LOOKUP[identifier] then
        return { TYPE = "Keyword", Value = identifier }
      elseif TOKENIZER_LUA_CONSTANTS_LOOKUP[identifier] then
        return { TYPE = "Constant", Value = identifier }
      else
        return { TYPE = "Identifier", Value = identifier }
      end
    elseif isString(curChar) then
      return { TYPE = "String", Value = consumeString() }
    elseif isVarArg() then
      consume(2)
      return { TYPE = "VarArg" }
    end

    local operator = consumeOperator()
    if operator then
      return { TYPE = "Operator", Value = operator }
    end
    return { TYPE = "Character", Value = curChar }
  end

  --// MAIN //--
  local function tokenize()
    local tokens = {}
    while curChar ~= "\0" do
      local token = getNextToken()
      if token then
        table.insert(tokens, token)
      end
      consume()
    end
    return tokens
  end

  return tokenize()
end

--/// Parser ///--
local PARSER_UNARY_OPERATOR_PRECEDENCE = 8
local PARSER_STOP_KEYWORDS       = createLookupTable({ "end", "else", "elseif", "until" })
local PARSER_OPERATOR_PRECEDENCE = { ["+"]   = {6, 6},  ["-"]  = {6, 6},
                                     ["*"]   = {7, 7},  ["/"]  = {7, 7}, ["%"] = {7, 7},
                                     ["^"]   = {10, 9}, [".."] = {5, 4},
                                     ["=="]  = {3, 3},  ["~="] = {3, 3},
                                     ["<"]   = {3, 3},  [">"]  = {3, 3}, ["<="] = {3, 3}, [">="] = {3, 3},
                                     ["and"] = {2, 2},  ["or"] = {1, 1} }
local PARSER_LUA_UNARY_OPERATORS  = createLookupTable({ "-", "#", "not" })
local PARSER_LUA_BINARY_OPERATORS = createLookupTable({ "+",  "-",   "*",  "/",
                                      "%",  "^",   "..", "==",
                                      "~=", "<",   ">",  "<=",
                                      ">=", "and", "or" })

--* Parser *--
local Parser = {}
function Parser.parse(tokens)
  local tokens            = tokens
  local currentToken      = tokens[1]
  local currentTokenIndex = 1
  local scopeStack        = {}
  local currentScope      = {}

  --// TOKEN NAVIGATION //--
  local function lookAhead(n)
    local updatedTokenIndex = currentTokenIndex + (n or 1)
    local updatedToken      = tokens[updatedTokenIndex]
    return updatedToken
  end
  local function consume(n)
    local updatedTokenIndex = currentTokenIndex + (n or 1)
    local updatedToken      = tokens[updatedTokenIndex]
    currentTokenIndex = updatedTokenIndex
    currentToken      = updatedToken
    return updatedToken
  end

  --// SCOPE MANAGEMENT //--
  local function enterScope(isFunctionScope)
    local scope = {
      localVariables = {},
      isFunctionScope = (isFunctionScope or false)
    }
    table.insert(scopeStack, scope)
    currentScope = scope
    return scope
  end
  local function exitScope()
    scopeStack[#scopeStack] = nil
    currentScope = scopeStack[#scopeStack]
  end

  --// IN-SCOPE VARIABLE MANAGEMENT //--
  local function declareLocalVariable(variable)
    currentScope.localVariables[variable] = true
  end
  local function declareLocalVariables(variables)
    for _, variable in ipairs(variables) do
      declareLocalVariable(variable)
    end
  end
  local function getVariableType(variableName)
    local isUpvalue = false
    for scopeIndex = #scopeStack, 1, -1 do
      local scope = scopeStack[scopeIndex]
      if scope.localVariables[variableName] then
        if isUpvalue then
          return "Upvalue", scopeIndex
        end
        return "Local", scopeIndex
      elseif scope.isFunctionScope then
        isUpvalue = true
      end
    end
    return "Global"
  end

  --// TOKEN CHECKERS //--
  local function checkToken(tokenType, tokenValue, token)
    local token = token or currentToken
    return token
          and token.TYPE  == tokenType
          and token.Value == tokenValue
  end
  local function isComma(token)
    return token and token.TYPE == "Character" and token.Value == ","
  end
  local function isUnaryOperator(token)
    return token and token.TYPE == "Operator" and PARSER_LUA_UNARY_OPERATORS[token.Value]
  end
  local function isBinaryOperator(token)
    return token and token.TYPE == "Operator" and PARSER_LUA_BINARY_OPERATORS[token.Value]
  end

  --// NODE CHECKERS //--
  local function isValidAssignmentLvalue(node)
    local nodeType = node.TYPE
    return nodeType == "Variable" or nodeType == "TableIndex"
  end

  --// EXPECTORS //--
  local function expectTokenType(tokenType, dontConsume)
    assert(currentToken and currentToken.TYPE == tokenType, "Expected a " .. tokenType .. ", got: " .. (currentToken or {}).TYPE)
    if not dontConsume then consume() end
  end
  local function expectCharacter(character, dontConsume)
    assert(currentToken and currentToken.TYPE == "Character", "Expected a character, got: " .. (currentToken or {}).TYPE)
    assert(currentToken.Value == character, "Expected '" .. character .. "'")
    if not dontConsume then consume() end
  end
  local function expectKeyword(keyword, dontConsume)
    assert(currentToken and currentToken.TYPE == "Keyword", "Expected a keyword, got: " .. (currentToken or {}).TYPE)
    assert(currentToken.Value == keyword, "Expected '" .. keyword .. "'")
    if not dontConsume then consume() end
  end

  --// AUXILIARY FUNCTIONS //--
  local getNextNode, parseCodeBlock
  local consumeExpression, consumeExpressions
  local function adjustMultiretNodes(nodeList, expectedReturnAmount)
    local lastNode = nodeList[#nodeList]
    local extra = expectedReturnAmount - #nodeList
    if lastNode and (lastNode.TYPE == "Vararg" or lastNode.TYPE == "FunctionCall") then
      extra = extra + 1
      if extra < 0 then extra = -1 end
      lastNode.ReturnValueAmount = extra
    else
      for _ = 1, extra do
        table.insert(nodeList, { TYPE = "Constant", Value = "nil" })
      end
    end
  end

  --// PARSERS //--
  local function consumeIdentifierList()
    local identifiers = {}
    while currentToken.TYPE == "Identifier" do
      table.insert(identifiers, currentToken.Value)
      if not isComma(lookAhead()) then break end
      consume() -- Consume identifier
      consume() -- Consume comma
    end
    return identifiers
  end
  local function consumeParameterList()
    expectCharacter("(")
    local parameters, isVarArg = {}, false
    while not checkToken("Character", ")") do
      if currentToken.TYPE == "Identifier" then
        table.insert(parameters, currentToken.Value)
      elseif currentToken.TYPE == "VarArg" then
        isVarArg = true
        consume() -- Consume the "..."
        break
      end
      consume() -- Consume the last token of the parameter
      if not isComma(currentToken) then break end
      consume() -- Consume the comma
    end
    expectCharacter(")")
    return parameters, isVarArg
  end
  local function consumeTableIndex(currentExpression)
    consume() -- Consume the "." symbol
    local indexToken = { TYPE = "String", Value = currentToken.Value }
    return { TYPE = "TableIndex", Index = indexToken, Expression = currentExpression }
  end
  local function consumeBracketTableIndex(currentExpression)
    consume() -- Consume the "[" symbol
    local indexExpression = consumeExpression()
    consume() -- Consume the last token of the index expression
    expectCharacter("]", true)
    return { TYPE = "TableIndex", Index = indexExpression, Expression = currentExpression }
  end
  local function consumeTable()
    consume() -- Consume the "{" symbol
    local elements = {}
    local internalImplicitKey = 1

    -- Consume table elements
    while not checkToken("Character", "}") do
      local key, value
      local isImplicitKey = false

      -- [<expression>] = <expression>
      if checkToken("Character", "[") then
        consume() -- Consume "["
        key = consumeExpression()
        consume() -- Consume the last token of the key
        expectCharacter("]")
        expectCharacter("=")
        value = consumeExpression()

      -- <identifier> = <expression>
      elseif currentToken.TYPE == "Identifier" and checkToken("Character", "=", lookAhead()) then
        key = { TYPE = "String", Value = currentToken.Value }
        consume() -- Consume key
        consume() -- Consume "="
        value = consumeExpression()

      -- <expression>
      else
        key = { TYPE = "Number", Value = internalImplicitKey }
        internalImplicitKey = internalImplicitKey + 1
        isImplicitKey = true
        value = consumeExpression()
      end
      table.insert(elements, { TYPE = "TableElement", Key = key, Value = value, IsImplicitKey = isImplicitKey })

      consume() -- Consume the last token of the expression
      local shouldContinue = checkToken("Character", ",") or checkToken("Character", ";")
      if not shouldContinue then break end
      consume() -- Consume "," or ";"
    end

    return { TYPE = "Table", Elements = elements }
  end
  local function consumeFunctionCall(currentExpression)
    consume() -- Consume the "("
    local arguments = consumeExpressions()
    adjustMultiretNodes(arguments, -1)
    consume() -- Consume the last token of the expression
    return { TYPE = "FunctionCall", Expression = currentExpression, Arguments = arguments, ReturnValueAmount = 1 }
  end
  local function consumeMethodCall(currentExpression)
    local methodIdentifier = consume().Value -- Consume the ":" character, and get the method identifier
    consume() -- Consume the method identifier
    local methodIndexNode = { TYPE = "TableIndex", Index = { TYPE = "String", Value = methodIdentifier }, Expression = currentExpression }
    local functionCallNode = consumeFunctionCall(methodIndexNode)
    functionCallNode.TYPE = "MethodCall"
    return functionCallNode
  end
  local function consumeOptionalSemilcolon()
    local nextToken = lookAhead()
    if checkToken("Character", ";", nextToken) then
      consume()
    end
  end

  --// EXPRESSSION PARSERS //--
  local parsePrimaryExpression, parseSuffixExpression,
        parsePrefixExpression,  parseUnaryOperator,
        parseBinaryExpression
  function parsePrimaryExpression()
    if not currentToken then return end
    local tokenType = currentToken.TYPE
    local tokenValue = currentToken.Value

    if tokenType == "Number" or tokenType == "String"
     or tokenType == "Constant" or tokenType == "VarArg" then
      return currentToken
    elseif tokenType == "Identifier" then
      local variableType = getVariableType(tokenValue)
      local variableNode = { TYPE = "Variable", Value = tokenValue, VariableType = variableType }
      return variableNode
    elseif tokenType == "Character" then
      if tokenValue == "(" then -- Parenthesized expression
        consume() -- Consume the parenthesis
        local expression = consumeExpression()
        consume() -- Consume the last token of the expression
        return expression
      elseif tokenValue == "{" then -- Table constructor
        return consumeTable()
      end
    elseif tokenType == "Keyword" then
      if tokenValue == "function" then
        consume() -- Consume the "function" token
        local parameters, isVarArg = consumeParameterList()
        local codeblock = parseCodeBlock(true, parameters)
        expectKeyword("end", true)
        return { TYPE = "Function", Codeblock = codeblock, Parameters = parameters, IsVarArg = isVarArg }
      end
    end
    return nil
  end
  function parseSuffixExpression(primaryExpression)
    local nextToken = lookAhead()
    local nextTokenValue = nextToken and nextToken.Value
    if nextTokenValue == "(" then -- Function call
      consume()
      -- <expression> \( <args> \)
      return consumeFunctionCall(primaryExpression)
    elseif nextTokenValue == "." then -- Table access
      consume()
      -- <expression> \. <identifier>
      return consumeTableIndex(primaryExpression)
    elseif nextTokenValue == ":" then -- Method call
      consume()
      -- <expression> \: <identifier> \( <args> \)
      return consumeMethodCall(primaryExpression)
    elseif nextTokenValue == "[" then -- Table index
      consume()
      -- <expression> \[ <expression> \]
      return consumeBracketTableIndex(primaryExpression)
    end
    return nil
  end
  function parsePrefixExpression(precedence)
    local primaryExpression = parsePrimaryExpression(precedence) -- <primary>
    if not primaryExpression then return end

    -- <suffix>*
    while (true) do
      local newExpression = parseSuffixExpression(primaryExpression)
      if not newExpression then break end
      primaryExpression = newExpression
    end

    return primaryExpression
  end
  function parseUnaryOperator()
    local unaryOperator = currentToken
    -- <unary> ::= <unary operator> <unary> | <primary>
    if not isUnaryOperator(currentToken) then
      return parsePrefixExpression(PARSER_UNARY_OPERATOR_PRECEDENCE)
    end

    -- <unary operator> <unary>
    consume() -- Consume the operator
    local expression = parseBinaryExpression(PARSER_UNARY_OPERATOR_PRECEDENCE)
    return { TYPE = "UnaryOperator", Operator = unaryOperator.Value, Operand = expression }
  end
  function parseBinaryExpression(minPrecedence)
    -- <binary> ::= <unary> <binary operator> <binary> | <unary>
    local minPrecedence = minPrecedence or 0
    local expression = parseUnaryOperator() -- <unary>
    if not expression then return end

    -- [<binary operator> <binary>]
    while true do
      local operatorToken = lookAhead()
      local precedence = operatorToken and PARSER_OPERATOR_PRECEDENCE[operatorToken.Value]
      if not isBinaryOperator(operatorToken) or precedence[1] <= minPrecedence then
        break
      end

      -- The <binary operator> <binary> part itself
      local nextToken = consume(2) -- Advance to and consume the operator
      if not nextToken then error("Unexpected end") end

      local right = parseBinaryExpression(precedence[2])
      if not right then error("Unexpected end") end

      expression = { TYPE = "BinaryOperator",
        Operator = operatorToken.Value,
        Left = expression, Right = right }
    end
    return expression
  end
  function consumeExpression(returnRawNode)
    local expression = parseBinaryExpression(0)
    if not expression then
      consume(-1)
      return
    end
    if returnRawNode then return expression end
    return { TYPE = "Expression", Value = expression }
  end
  function consumeExpressions()
    local expressions = { consumeExpression(true) }
    if #expressions == 0 then return {} end

    local nextToken = lookAhead()
    while isComma(nextToken) do
      consume(2) -- Consume the last token of the last expression and ","
      local expression = consumeExpression(true)
      table.insert(expressions, expression)
      nextToken = lookAhead()
    end

    return expressions
  end

  --// STATEMENT PARSERS //--
  local function parseLocal()
    consume() -- Consume the "local" token
    if checkToken("Keyword", "function") then
      consume() -- Consume the "function" token
      local name = currentToken.Value
      consume() -- Consume the last token of the identifier)
      local parameters, isVarArg = consumeParameterList()
      declareLocalVariable(name)
      local codeblock = parseCodeBlock(true, parameters)
      expectKeyword("end", true)
      return { TYPE = "LocalFunctionDeclaration", Name = name, Codeblock = codeblock, Parameters = parameters, IsVarArg = isVarArg }
    end
    local variables = consumeIdentifierList()
    if checkToken("Character", "=", lookAhead()) then
      consume() -- Consume the last token of the last identifier
      expectCharacter("=")
      local expressions = consumeExpressions()
      declareLocalVariables(variables)
      return { TYPE = "LocalDeclaration", Variables = variables, Expressions = expressions }
    else
      declareLocalVariables(variables)
      return { TYPE = "LocalDeclaration", Variables = variables, Expressions = {} }
    end
  end
  local function parseWhile()
    consume() -- Consume the "while" token
    local condition = consumeExpression()
    consume() -- Consume the last token of the condition
    expectKeyword("do")
    local codeblock = parseCodeBlock()
    expectKeyword("end", true)
    return { TYPE = "WhileLoop", Condition = condition, Codeblock = codeblock }
  end
  local function parseRepeat()
    consume() -- Consume the "repeat" token
    local codeblock = parseCodeBlock()
    expectKeyword("until")
    local condition = consumeExpression()
    return { TYPE = "RepeatLoop", Codeblock = codeblock, Condition = condition }
  end
  local function parseDo()
    consume() -- Consume the "do" token
    local codeblock = parseCodeBlock()
    expectKeyword("end", true)
    return { TYPE = "DoBlock", Codeblock = codeblock }
  end
  local function parseReturn()
    consume() -- Consume the "return" token
    local expressions = consumeExpressions()
    return { TYPE = "ReturnStatement", Expressions = expressions }
  end
  local function parseBreak()
    return { TYPE = "BreakStatement" }
  end
  local function parseIf()
    consume() -- Consume the "if" token
    local condition = consumeExpression()
    consume() -- Consume the last token of the condition
    expectKeyword("then")
    local codeblock = parseCodeBlock()
    local elseifs = {}
    while checkToken("Keyword", "elseif") do
      consume() -- Consume the "elseif" token
      local elseifCondition = consumeExpression()
      consume() -- Consume the last token of the condition
      expectKeyword("then")
      local elseifCodeblock = parseCodeBlock()
      table.insert(elseifs, { Condition = elseifCondition, Codeblock = elseifCodeblock })
    end
    local elseCodeblock
    if checkToken("Keyword", "else") then
      consume() -- Consume the "else" token
      elseCodeblock = parseCodeBlock()
    end
    expectKeyword("end", true)
    return { TYPE = "IfStatement", Condition = condition, Codeblock = codeblock, ElseIfs = elseifs, ElseCodeblock = elseCodeblock }
  end
  local function parseFor()
    consume() -- Consume the "for" token
    expectTokenType("Identifier", true)
    local variableName = currentToken.Value
    consume() -- Consume the variable name
    if checkToken("Character", ",") or checkToken("Keyword", "in") then
      local iteratorVariables = { variableName }
      while checkToken("Character", ",") do
        consume() -- Consume the comma
        expectTokenType("Identifier", true)
        local newVariableName = currentToken.Value
        table.insert(iteratorVariables, newVariableName)
        consume() -- Consume the variable name
      end
      expectKeyword("in")
      local expressions = consumeExpressions()
      adjustMultiretNodes(expressions, 3)
      consume() -- Consume the last token of the expressions
      expectKeyword("do")
      local codeblock = parseCodeBlock(false, iteratorVariables)
      expectKeyword("end", true)
      return { TYPE = "GenericForLoop", IteratorVariables = iteratorVariables, Expressions = expressions, Codeblock = codeblock }
    end
    expectCharacter("=")
    local expressions = consumeExpressions()
    consume() -- Consume the last token of the expressions
    expectKeyword("do")
    local codeblock = parseCodeBlock(false, { variableName })
    expectKeyword("end", true)
    return { TYPE = "NumericForLoop", VariableName = variableName, Expressions = expressions, Codeblock = codeblock }
  end
  local function parseFunction()
    consume() -- Consume the "function" token
    expectTokenType("Identifier", true)
    local variableName = currentToken.Value
    local variableType = getVariableType(variableName)
    local expression = { TYPE = "Variable", Value = variableName, VariableType = variableType }
    local fields, isMethod = { }, false
    while consume() do
      if checkToken("Character", ".") then
        consume() -- Consume the "."
        expectTokenType("Identifier", true)
        local fieldName = currentToken.Value
        table.insert(fields, fieldName)
      elseif checkToken("Character", ":") then
        consume() -- Consume the ":"
        expectTokenType("Identifier", true)
        local methodName = currentToken.Value
        table.insert(fields, methodName)
        isMethod = true
        consume() -- Consume the method name
        break
      else break end
    end
    local parameters, isVarArg = consumeParameterList()
    local codeblock = parseCodeBlock(true, parameters)
    expectKeyword("end", true)
    return { TYPE = "FunctionDeclaration",
      Expression = expression,
      Fields = fields,
      IsMethod = isMethod,
      Codeblock = codeblock,
      Parameters = parameters,
      IsVarArg = isVarArg
    }
  end
  local function parseAssignment(lvalue)
    local lvalues = { lvalue }
    consume() -- Consume the last token of the lvalue
    while isComma(currentToken) do
      consume() -- Consume the comma
      local nextLValue = parsePrefixExpression()
      if not nextLValue then error("Expected an lvalue") end
      if not isValidAssignmentLvalue(nextLValue) then
        error("Expected a variable or index, got: " .. nextLValue.TYPE)
      end
      table.insert(lvalues, nextLValue)
      consume() -- Consume the last token of the lvalue
    end
    expectCharacter("=")
    local expressions = consumeExpressions()
    return { TYPE = "VariableAssignment", LValues = lvalues, Expressions = expressions }
  end
  local function parseFunctionCallOrVariableAssignment()
    local lvalue = parsePrefixExpression()
    local lvalueType = tostring(lvalue and lvalue.TYPE)
    if lvalue then
      if isValidAssignmentLvalue(lvalue) then
        return parseAssignment(lvalue)
      elseif lvalueType == "FunctionCall" or lvalueType == "MethodCall" then
        lvalue.ReturnValueAmount = 0
        return lvalue
      else
        error("Unexpected lvalue type: " .. lvalueType)
      end
    end
    error("Expected an lvalue, got: " .. lvalueType)
  end

  --// CODE BLOCK PARSERS //--
  function getNextNode()
    local currentTokenValue = currentToken.Value
    local currentTokenType = currentToken.TYPE
    if currentTokenType == "Keyword" then
      local node
      if PARSER_STOP_KEYWORDS[currentTokenValue] then return
      elseif currentTokenValue == "local"        then node = parseLocal()
      elseif currentTokenValue == "while"        then node = parseWhile()
      elseif currentTokenValue == "repeat"       then node = parseRepeat()
      elseif currentTokenValue == "do"           then node = parseDo()
      elseif currentTokenValue == "return"       then node = parseReturn()
      elseif currentTokenValue == "break"        then node = parseBreak()
      elseif currentTokenValue == "if"           then node = parseIf()
      elseif currentTokenValue == "for"          then node = parseFor()
      elseif currentTokenValue == "function"     then node = parseFunction()
      else error("Unsupported keyword: " .. currentTokenValue) end
      consumeOptionalSemilcolon()
      return node
    end

    local node = parseFunctionCallOrVariableAssignment()
    consumeOptionalSemilcolon()
    return node
  end
  function parseCodeBlock(isFunctionScope, variablesInCodeblock)
    enterScope(isFunctionScope)
    if variablesInCodeblock then
      declareLocalVariables(variablesInCodeblock)
    end
    local nodeList = { TYPE = "Group" }
    while currentToken do
      local node = getNextNode()
      if not node then break end
      table.insert(nodeList, node)
      consume()
    end
    exitScope()
    return nodeList
  end

  --// MAIN //--
  local function parse()
    local ast = parseCodeBlock()
    ast.TYPE = "AST"
    return ast
  end

  return parse()
end

--// Compiler //--
local unpack = (unpack or table.unpack)

local MODE_iABC = 0
local MODE_iABx = 1
local MODE_iAsBx = 2

local COMPILER_OPCODE_TO_NUMBER_LOOKUP = {
  ["MOVE"]     = 0,  ["LOADK"]     = 1,  ["LOADBOOL"] = 2,  ["LOADNIL"]   = 3,
  ["GETUPVAL"] = 4,  ["GETGLOBAL"] = 5,  ["GETTABLE"] = 6,  ["SETGLOBAL"] = 7,
  ["SETUPVAL"] = 8,  ["SETTABLE"]  = 9,  ["NEWTABLE"] = 10, ["SELF"]      = 11,
  ["ADD"]      = 12, ["SUB"]       = 13, ["MUL"]      = 14, ["DIV"]       = 15,
  ["MOD"]      = 16, ["POW"]       = 17, ["UNM"]      = 18, ["NOT"]       = 19,
  ["LEN"]      = 20, ["CONCAT"]    = 21, ["JMP"]      = 22, ["EQ"]        = 23,
  ["LT"]       = 24, ["LE"]        = 25, ["TEST"]     = 26, ["TESTSET"]   = 27,
  ["CALL"]     = 28, ["TAILCALL"]  = 29, ["RETURN"]   = 30, ["FORLOOP"]   = 31,
  ["FORPREP"]  = 32, ["TFORLOOP"]  = 33, ["SETLIST"]  = 34, ["CLOSE"]     = 35,
  ["CLOSURE"]  = 36, ["VARARG"]    = 37
}
local COMPILER_OPMODES = {
  [0] = MODE_iABC,  [1]  = MODE_iABx,  [2]  = MODE_iABC,
  [3] = MODE_iABC,  [4]  = MODE_iABC,  [5]  = MODE_iABx,
  [6] = MODE_iABC,  [7]  = MODE_iABx,  [8]  = MODE_iABC,
  [9] = MODE_iABC,  [10] = MODE_iABC,  [11] = MODE_iABC,
  [12] = MODE_iABC, [13] = MODE_iABC,  [14] = MODE_iABC,
  [15] = MODE_iABC, [16] = MODE_iABC,  [17] = MODE_iABC,
  [18] = MODE_iABC, [19] = MODE_iABC,  [20] = MODE_iABC,
  [21] = MODE_iABC, [22] = MODE_iAsBx, [23] = MODE_iABC,
  [24] = MODE_iABC, [25] = MODE_iABC,  [26] = MODE_iABC,
  [27] = MODE_iABC, [28] = MODE_iABC,  [29] = MODE_iABC,
  [30] = MODE_iABC, [31] = MODE_iAsBx, [32] = MODE_iAsBx,
  [33] = MODE_iABC, [34] = MODE_iABC,  [35] = MODE_iABC,
  [36] = MODE_iABx, [37] = MODE_iABC
}

local COMPILER_SIMPLE_ARICHMETIC_OPERATOR_LOOKUP = {
  ["+"] = "ADD", ["-"] = "SUB", ["*"] = "MUL", ["/"] = "DIV",
  ["%"] = "MOD", ["^"] = "POW"
}
local COMPILER_CONDITIONAL_OPERATOR_LOOKUP = {
  ["=="] = "EQ", ["~="] = "EQ",
  ["<"]  = "LT", [">"]  = "LT",
  ["<="] = "LE", [">="] = "LE"
}
local COMPILER_UNARY_OPERATOR_LOOKUP = {
  ["-"] = "UNM", ["#"] = "LEN", ["not"] = "NOT"
}

local COMPILER_CONTROL_FLOW_OPERATOR_LOOKUP = createLookupTable({"and", "or"})
local NEGATIVE_CONDITIONAL_OPERATOR_LOOKUP = createLookupTable({"~=", ">", ">="})
local POSITIVE_CONDITIONAL_OPERATOR_LOOKUP = createLookupTable({"==", "<", "<="})

--* Compiler *--
local Compiler = {}
function Compiler.compile(ast)
  local breakInstructions
  local currentProto
  local locals, takenRegisters, code, constants,
        constantLookup, upvalues, upvalueLookup,
        protos, numParams, isVarArg, functionName

  --// PROTO MANAGEMENT //--
  local function setProto(proto)
    currentProto   = proto
    locals         = proto.locals
    takenRegisters = proto.takenRegisters
    code           = proto.code
    constants      = proto.constants
    constantLookup = proto.constantLookup
    upvalues       = proto.upvalues
    upvalueLookup  = proto.upvalueLookup
    protos         = proto.protos
    numParams      = proto.numParams
    isVarArg       = proto.isVarArg
    functionName   = proto.functionName
  end
  local function newProto()
    currentProto = {
      locals         = {},
      takenRegisters = {},
      code           = {},
      constants      = {},
      constantLookup = {},
      upvalues       = {},
      upvalueLookup  = {},
      protos         = {},
      numParams      = 0,
      isVarArg       = false,
      functionName   = "@tlc",
    }
    setProto(currentProto)
    return currentProto
  end

  --// REGISTER MANAGEMENT //--
  local function allocateRegister()
    for i = 0, 255 do
      if not takenRegisters[i] then
        takenRegisters[i] = true
        return i
      end
    end
    error("Out of registers")
  end
  local function deallocateRegister(register)
    takenRegisters[register] = nil
  end
  local function deallocateRegisters(registers)
    for _, register in ipairs(registers) do
      takenRegisters[register] = nil
    end
  end

  --// UTILITY FUNCTIONS //--
  local function findOrCreateConstant(value)
    if constantLookup[value] then
      return constantLookup[value]
    end
    table.insert(constants, value)
    local constantIndex = -(#constants)
    constantLookup[value] = constantIndex
    return constantIndex
  end
  local function findOrCreateUpvalue(value)
    if upvalueLookup[value] then
      return upvalueLookup[value]
    end
    table.insert(upvalues, value)
    local upvalueIndex = #upvalues - 1
    upvalueLookup[value] = upvalueIndex
    return upvalueIndex
  end
  local function addInstruction(opname, a, b, c)
    local instruction = { opname, a, b, c }
    table.insert(code, instruction)
    return instruction, #code
  end
  local function registerVariable(localName, register)
    locals[localName] = register
  end
  local function unregisterVariable(localName)
    locals[localName] = nil
  end
  local function unregisterVariables(variables)
    for _, variable in ipairs(variables) do
      unregisterVariable(variable)
    end
  end

  --// CODE GENERATION //--
  local processExpressionNode, processStatementNode, processCodeBlock, processFunction
  function processExpressionNode(node, expressionRegister)
    local expressionRegister = expressionRegister or allocateRegister()
    local nodeType = node.TYPE
    while nodeType == "Expression" do
      node = node.Value
      nodeType = node.TYPE
    end

    if nodeType == "Number" or nodeType == "String" then
      addInstruction("LOADK", expressionRegister, findOrCreateConstant(node.Value))
    elseif nodeType == "Function" then
      local codeblock  = node.Codeblock
      local parameters = node.Parameters
      local isVarArg   = node.isVarArg
      processFunction(codeblock, expressionRegister, parameters, isVarArg)
    elseif nodeType == "FunctionCall" then
      processExpressionNode(node.Expression, expressionRegister)
      local argumentRegisters = {}
      for index, argument in ipairs(node.Arguments) do
        argumentRegisters[index] = processExpressionNode(argument)
      end
      local returnAmount = node.ReturnValueAmount + 1
      local argumentAmount = #node.Arguments + 1
      if returnAmount <= 0 then returnAmount = 0 end
      if node.Arguments[#node.Arguments] then
        local lastArgument = node.Arguments[#node.Arguments]
        if lastArgument.TYPE == "FunctionCall" or lastArgument.TYPE == "VarArg" then
          argumentAmount = 0
        end
      end
      addInstruction("CALL", expressionRegister, argumentAmount, returnAmount)
      deallocateRegisters(argumentRegisters)
    elseif nodeType == "MethodCall" then
      local nodeIndexIndex      = node.Expression.Index
      local nodeIndexExpression = node.Expression.Expression
      processExpressionNode(nodeIndexExpression, expressionRegister)
      local selfArgumentRegister = allocateRegister()
      local nodeIndexRegister = processExpressionNode(nodeIndexIndex)
      addInstruction("SELF", expressionRegister, expressionRegister, nodeIndexRegister)
      deallocateRegister(nodeIndexRegister)
      local argumentRegisters = { selfArgumentRegister } -- Allocate the self register
      for index, argument in ipairs(node.Arguments) do
        table.insert(argumentRegisters, processExpressionNode(argument))
      end
      local returnAmount = node.ReturnValueAmount + 1
      local argumentAmount = #node.Arguments + 2
      if returnAmount <= 0 then returnAmount = 0 end
      addInstruction("CALL", expressionRegister, argumentAmount, returnAmount)
      deallocateRegisters(argumentRegisters)
    elseif nodeType == "Constant" then
      local nodeValue = node.Value
      if nodeValue ~= "nil" then
        addInstruction("LOADBOOL", expressionRegister, nodeValue == "true" and 1 or 0, 0)
      else
        addInstruction("LOADNIL", expressionRegister, expressionRegister)
      end
    elseif nodeType == "TableIndex" then
      local indexRegister = processExpressionNode(node.Index)
      processExpressionNode(node.Expression, expressionRegister)
      addInstruction("GETTABLE", expressionRegister, expressionRegister, indexRegister)
      deallocateRegister(indexRegister)
    elseif nodeType == "Table" then
      local elements = node.Elements
      addInstruction("NEWTABLE", expressionRegister, 0, 0)
      local temporaryRegisters = {}
      local numberOfImplicitKeys = 0
      for _, element in ipairs(elements) do
        if element.ImplicitKey then
          table.insert(temporaryRegisters, processExpressionNode(element.Value))
          numberOfImplicitKeys = numberOfImplicitKeys + 1
        end
      end
      addInstruction("SETLIST", expressionRegister, numberOfImplicitKeys, 1)
      deallocateRegisters(temporaryRegisters)
      for _, element in ipairs(elements) do
        if not element.ImplicitKey then
          local valueRegister = processExpressionNode(element.Value)
          local keyRegister = processExpressionNode(element.Key)
          deallocateRegisters({ valueRegister, keyRegister })
          addInstruction("SETTABLE", expressionRegister, keyRegister, valueRegister)
        end
      end
    elseif nodeType == "Variable" then
      local variableType = node.VariableType
      if variableType == "Global" then
        addInstruction("GETGLOBAL", expressionRegister, findOrCreateConstant(node.Value))
      elseif variableType == "Local" then
        addInstruction("MOVE", expressionRegister, locals[node.Value])
      elseif variableType == "Upvalue" then
        addInstruction("GETUPVAL", expressionRegister, findOrCreateUpvalue(node.Value))
      end
    elseif nodeType == "BinaryOperator" then
      local nodeOperator = node.Operator
      local opcode = COMPILER_SIMPLE_ARICHMETIC_OPERATOR_LOOKUP[nodeOperator]
                     or COMPILER_CONDITIONAL_OPERATOR_LOOKUP[nodeOperator]
                     or COMPILER_CONTROL_FLOW_OPERATOR_LOOKUP[nodeOperator]
      if COMPILER_SIMPLE_ARICHMETIC_OPERATOR_LOOKUP[nodeOperator] then
        local leftExpressionRegister = processExpressionNode(node.Left)
        local rightExpressionRegister = processExpressionNode(node.Right)
        addInstruction(opcode, expressionRegister, leftExpressionRegister, rightExpressionRegister)
        deallocateRegisters({ leftExpressionRegister, rightExpressionRegister })
      elseif COMPILER_CONTROL_FLOW_OPERATOR_LOOKUP[nodeOperator] then
        local leftExpressionRegister = processExpressionNode(node.Left, expressionRegister)
        local isConditionTrue = (nodeOperator == "and" and 0) or 1
        addInstruction("TEST", leftExpressionRegister, 0, isConditionTrue)
        local jumpInstruction, jumpInstructionIndex = addInstruction("JMP", 0, 0) -- Placeholder
        processExpressionNode(node.Right, expressionRegister)
        jumpInstruction[3] = #code - jumpInstructionIndex
      elseif NEGATIVE_CONDITIONAL_OPERATOR_LOOKUP[nodeOperator] or POSITIVE_CONDITIONAL_OPERATOR_LOOKUP[nodeOperator] then
        local leftExpressionRegister = processExpressionNode(node.Left)
        local rightExpressionRegister = processExpressionNode(node.Right)
        local isConditionTrue = (NEGATIVE_CONDITIONAL_OPERATOR_LOOKUP[nodeOperator] and 0) or 1
        addInstruction(opcode, isConditionTrue, leftExpressionRegister, rightExpressionRegister)
        addInstruction("JMP", 0, 1)
        addInstruction("LOADBOOL", expressionRegister, 0, 1)
        addInstruction("LOADBOOL", expressionRegister, 1, 0)
        deallocateRegisters({ leftExpressionRegister, rightExpressionRegister })
      elseif nodeOperator == ".." then
        local leftExpressionRegister = processExpressionNode(node.Left)
        local rightExpressionRegister = processExpressionNode(node.Right)
        if (rightExpressionRegister - leftExpressionRegister) ~= 1 then
          error("Concatenation requires consecutive registers")
        end
        addInstruction("CONCAT", expressionRegister, leftExpressionRegister, rightExpressionRegister)
        deallocateRegisters({ leftExpressionRegister, rightExpressionRegister })
      else
        error("Unsupported binary operator: " .. tostring(nodeOperator))
      end
    elseif nodeType == "UnaryOperator" then
      local nodeOperator = node.Operator
      local operatorOpcode = COMPILER_UNARY_OPERATOR_LOOKUP[nodeOperator]
      if not operatorOpcode then
        error("Unsupported unary operator: " .. tostring(nodeOperator))
      end
      local operandExpression = processExpressionNode(node.Operand)
      addInstruction(operatorOpcode, expressionRegister, operandExpression)
      deallocateRegister(operandExpression)
    else
      error("Unsupported expression node type: " .. tostring(nodeType))
    end

    return expressionRegister
  end
  function processStatementNode(node)
    local nodeType = node.TYPE
    if nodeType == "FunctionCall" or nodeType == "MethodCall" then
      local functionRegister = processExpressionNode(node)
      deallocateRegister(functionRegister)
    elseif nodeType == "BreakStatement" then
      local jumpInstruction, jumpInstructionIndex = addInstruction("JMP", 0, 0) -- Placeholder
      table.insert(breakInstructions, jumpInstructionIndex)
    elseif nodeType == "LocalFunctionDeclaration" then
      local name          = node.Name
      local codeblock     = node.Codeblock
      local parameters    = node.Parameters
      local isVarArg      = node.IsVarArg
      local localRegister = allocateRegister()
      processFunction(codeblock, localRegister, parameters, isVarArg)
      registerVariable(name, localRegister)
    elseif nodeType == "FunctionDeclaration" then
      local expression         = node.Expression
      local fields             = node.Fields
      local isMethod           = node.IsMethod
      local codeblock          = node.Codeblock
      local parameters         = node.Parameters
      local isVarArg           = node.IsVarArg
      if #fields > 0 then
        local closureRegister = allocateRegister()
        processFunction(codeblock, closureRegister, parameters, isVarArg)
        local expressionRegister = processExpressionNode(expression)
        for index, field in ipairs(fields) do
          local fieldRegister = allocateRegister()
          addInstruction("LOADK", fieldRegister, findOrCreateConstant(field))
          if index == #fields then addInstruction("SETTABLE", expressionRegister, fieldRegister, closureRegister)
          else                     addInstruction("GETTABLE", expressionRegister, expressionRegister, fieldRegister)
          end
          deallocateRegister(fieldRegister)
        end
        deallocateRegisters({ expressionRegister, closureRegister })
        return
      end
      local isLocal = expression.VariableType == "Local"
      if isLocal then
        local localRegister = locals[expression.Value]
        processFunction(codeblock, localRegister, parameters, isVarArg)
      end
    elseif nodeType == "LocalDeclaration" then
      local expressionRegisters = {}
      for index, expression in ipairs(node.Expressions) do
        local expressionRegister = processExpressionNode(expression)
        table.insert(expressionRegisters, expressionRegister)
        if not node.Variables[index] then
          -- If this expression doesn't have a corresponding variable, deallocate it
          deallocateRegister(expressionRegister)
        end
      end
      for index, localName in ipairs(node.Variables) do
        local expressionRegister = expressionRegisters[index]
        if not expressionRegister then
          -- Load nil into the register
          expressionRegister = allocateRegister()
          addInstruction("LOADNIL", expressionRegister, expressionRegister)
        end
        registerVariable(localName, expressionRegister)
      end
    elseif nodeType == "NumericForLoop" then
      local variableName = node.VariableName
      local expressions = node.Expressions
      local codeblock = node.Codeblock
      local startRegister = processExpressionNode(expressions[1])
      local endRegister = processExpressionNode(expressions[2])
      local stepRegister
      if expressions[3] then
        stepRegister = processExpressionNode(expressions[3])
      else
        stepRegister = allocateRegister()
        addInstruction("LOADK", stepRegister, findOrCreateConstant(1))
      end
      local forprepInstruction = addInstruction("FORPREP", startRegister, 0) -- Placeholder
      local loopStart = #code
      registerVariable(variableName, startRegister)
      local oldBreakInstructions = breakInstructions
      breakInstructions = {}
      processCodeBlock(codeblock)
      local loopEnd = #code
      addInstruction("FORLOOP", startRegister, loopStart - loopEnd - 1)
      forprepInstruction[3] = loopEnd - loopStart
      for _, breakInstructionIndex in ipairs(breakInstructions) do
        code[breakInstructionIndex][3] = #code - breakInstructionIndex
      end
      breakInstructions = oldBreakInstructions
      unregisterVariable(variableName)
      deallocateRegisters({ startRegister, endRegister, stepRegister })
    elseif nodeType == "GenericForLoop" then
      local iteratorVariables = node.IteratorVariables
      local expressions = node.Expressions
      local codeblock = node.Codeblock
      local iteratorRegisters = {}
      local expressionRegister = processExpressionNode(expressions[1])
      local startJmpInstruction = addInstruction("JMP", 0, 0) -- Placeholder
      local forGeneratorRegister = expressionRegister
      local forStateRegister = allocateRegister()
      local forControlRegister = allocateRegister()
      registerVariable("(for generator)", forGeneratorRegister)
      registerVariable("(for state)", forStateRegister)
      registerVariable("(for control)", forControlRegister)
      local loopStart = #code
      for index, iteratorVariable in ipairs(iteratorVariables) do
        local iteratorRegister = allocateRegister()
        iteratorRegisters[index] = iteratorRegister
        registerVariable(iteratorVariable, iteratorRegister)
      end
      local oldBreakInstructions = breakInstructions
      breakInstructions = {}
      processCodeBlock(codeblock)
      local tforloopInstruction = addInstruction("TFORLOOP", expressionRegister, 0, #iteratorVariables)
      startJmpInstruction[3] = #code - loopStart - 1
      addInstruction("JMP", 0, loopStart - #code - 1)
      for _, breakInstructionIndex in ipairs(breakInstructions) do
        code[breakInstructionIndex][3] = #code - breakInstructionIndex
      end
      breakInstructions = oldBreakInstructions
      deallocateRegisters(iteratorRegisters)
      deallocateRegisters({ expressionRegister, forGeneratorRegister, forStateRegister, forControlRegister })
      unregisterVariables({ "(for generator)", "(for state)", "(for control)" })
      unregisterVariables(iteratorVariables)
      deallocateRegisters(iteratorRegisters)
    elseif nodeType == "ReturnStatement" then
      local expressionRegisters = {}
      for index, expression in ipairs(node.Expressions) do
        local expressionRegister = processExpressionNode(expression)
        table.insert(expressionRegisters, expressionRegister)
      end
      local startRegister = expressionRegisters[1] or 0
      addInstruction("RETURN", startRegister, #node.Expressions + 1, 0)
      deallocateRegisters(expressionRegisters)
    elseif nodeType == "WhileLoop" then
      local loopStart = #code
      local conditionRegister = processExpressionNode(node.Condition)
      addInstruction("TEST", conditionRegister, 0, 0)
      local jumpInstruction = addInstruction("JMP", 0, 0) -- Placeholder
      deallocateRegister(conditionRegister)
      local codeStart = #code
      local oldBreakInstructions = breakInstructions
      breakInstructions = {}
      processCodeBlock(node.Codeblock)
      local jumpBackInstruction = addInstruction("JMP", 0, loopStart - #code - 1)
      jumpInstruction[3] = #code - codeStart
      for _, breakInstructionIndex in ipairs(breakInstructions) do
        code[breakInstructionIndex][3] = #code - breakInstructionIndex
      end
      breakInstructions = oldBreakInstructions
    elseif nodeType == "RepeatLoop" then
      local loopStart = #code
      processCodeBlock(node.Codeblock)
      local conditionRegister = processExpressionNode(node.Condition)
      addInstruction("TEST", conditionRegister, 0, 0)
      local jumpInstruction = addInstruction("JMP", 0, loopStart - #code - 1)
      deallocateRegister(conditionRegister)
    elseif nodeType == "DoBlock" then
      processCodeBlock(node.Codeblock)
    elseif nodeType == "IfStatement" then
      local conditionCodeblockStatements = { { Condition = node.Condition, Codeblock = node.Codeblock } }
      for _, elseifNode in ipairs(node.ElseIfs) do
        table.insert(conditionCodeblockStatements, elseifNode)
      end

      local jumpToEndInstructions = {}
      for index, conditionCodeblockStatement in ipairs(conditionCodeblockStatements) do
        local condition = conditionCodeblockStatement.Condition
        local codeBlock = conditionCodeblockStatement.Codeblock

        local conditionRegister = processExpressionNode(condition)
        addInstruction("TEST", conditionRegister, 0, 0)
        local conditionJumpInstruction, conditionJumpInstructionIndex = addInstruction("JMP", 0, 0) -- Placeholder
        deallocateRegister(conditionRegister)
        processCodeBlock(codeBlock)
        if index < #conditionCodeblockStatements or node.ElseCodeblock then
          table.insert(jumpToEndInstructions, { addInstruction("JMP", 0, 0) })
        end
        conditionJumpInstruction[3] = #code - conditionJumpInstructionIndex
      end
      if node.ElseCodeblock then
        processCodeBlock(node.ElseCodeblock)
      end

      for _, jumpToEndInstruction in ipairs(jumpToEndInstructions) do
        local instructionTable, instructionIndex = jumpToEndInstruction[1], jumpToEndInstruction[2]
        instructionTable[3] = #code - instructionIndex
      end
    elseif nodeType == "VariableAssignment" then
      local expressionRegisters = {}
      for index, expression in ipairs(node.Expressions) do
        local expressionRegister = processExpressionNode(expression)
        table.insert(expressionRegisters, expressionRegister)
      end
      for index, lvalue in ipairs(node.LValues) do
        local lvalueType = lvalue.TYPE
        if lvalueType == "Variable" then
          local variableType = lvalue.VariableType
          local variableName = lvalue.Value
          local expressionRegister = expressionRegisters[index]
          if not expressionRegister then error("Expected an expression for assignment") end
          if variableType == "Local" then
            addInstruction("MOVE", locals[variableName], expressionRegister)
          elseif variableType == "Global" then
            addInstruction("SETGLOBAL", expressionRegister, findOrCreateConstant(variableName))
          end
        elseif lvalueType == "TableIndex" then
          local indexRegister = processExpressionNode(lvalue.Index)
          local tableExpressionRegister = processExpressionNode(lvalue.Expression)
          local expressionRegister = expressionRegisters[index]
          if not expressionRegister then error("Expected an expression for assignment") end
          addInstruction("SETTABLE", tableExpressionRegister, indexRegister, expressionRegister)
          deallocateRegisters({ indexRegister, expressionRegister, tableExpressionRegister })
        else
          error("Unsupported lvalue type: " .. lvalueType)
        end
      end
      deallocateRegisters(expressionRegisters)
    else
      error("Unsupported statement node type: " .. tostring(nodeType))
    end
  end
  function processCodeBlock(list)
    for index, node in ipairs(list) do
      processStatementNode(node)
    end
  end
  function processFunction(codeBlock, expressionRegister, parameters, isVarArg)
    local oldProto  = currentProto
    local proto     = newProto()
    proto.numParams = #parameters

    for _, parameter in ipairs(parameters) do
      registerVariable(parameter, allocateRegister())
    end
    processCodeBlock(codeBlock)

    addInstruction("RETURN", 0, 1) -- Default return statement
    setProto(oldProto)
    table.insert(protos, proto)
    addInstruction("CLOSURE", expressionRegister, #protos - 1)

    for index, upvalueName in ipairs(proto.upvalues) do
      local isLocal = locals[upvalueName] ~= nil
      if isLocal then
        addInstruction("MOVE", 0, locals[upvalueName])
      else
        addInstruction("GETUPVAL", 0, findOrCreateUpvalue(upvalueName))
      end
    end
    return proto
  end

  --// BYTE MANIPULATION (needed for compiling to bytecode) //--
  local function twosComplement(value)
    local value = value or 0
    if value < 0 then
      value = (-value) - 1
    end
    return value
  end
  local function makeOneByte(value)
    return string.char(value % 256)
  end
  local function makeTwoBytes(value)
    local bytes = {}
    for i = 1, 2 do
      bytes[i] = value % 256
      value = math.floor(value / 256)
    end
    return string.char(unpack(bytes))
  end
  local function makeFourBytes(value)
    local bytes = {}
    for i = 1, 4 do
      bytes[i] = value % 256
      value = math.floor(value / 256)
    end
    return string.char(unpack(bytes))
  end
  local function makeEightBytes(value)
    local bytes = {}
    for i = 1, 8 do
      bytes[i] = value % 256
      value = math.floor(value / 256)
    end
    return string.char(unpack(bytes))
  end
  local function makeDouble(value)
    local sign = (value < 0 and 1) or 0
    local value = math.abs(value)
    local mantissa, exponent = math.frexp(value)

    if value == 0 then -- zero
      mantissa, exponent = 0, 0
    elseif value == 1/0 then -- infinity
      mantissa, exponent = 0, 2047
    else
      mantissa = (mantissa * 2 - 1) * math.ldexp(0.5, 53)
      exponent = exponent + 1022
    end

    -- 52-bit mantissa
    local double = {}
    for index = 1, 6 do
      double[index] = mantissa % 256
      mantissa = math.floor(mantissa / 256)
    end

    -- exponent (11 bit)
    double[7] = ((mantissa % 16) + (exponent % 16) * 16) % 256
    double[8] = ((sign * 128) + math.floor(exponent / 16)) % 256
    return string.char(unpack(double))
  end

  --// BYTECODE GENERATION //--
  local makeString, makeConstant, makeInstruction, makeConstantSection,
        makeCodeSection, makeFunction, makeHeader
  function makeString(value)
    local value = value .. "\0"
    local size = makeEightBytes(#value)
    return size .. value
  end
  function makeConstant(constantValue, constantType)
    if constantType == "number" then
      return makeOneByte(3) .. makeDouble(constantValue)
    elseif constantType == "string" then
      return makeOneByte(4) .. makeString(constantValue)
    elseif constantType == "boolean" then
      local secondByte = (constantValue and 1) or 0
      return makeOneByte(1) .. makeOneByte(secondByte)
    elseif constantType == "nil" then
      return makeOneByte(0)
    else
      error("Unsupported constant type: " .. constantType)
    end
  end
  function makeInstruction(instruction)
    local opcode = COMPILER_OPCODE_TO_NUMBER_LOOKUP[instruction[1]]
    local opmode = COMPILER_OPMODES[opcode]
    local mode = opmode
    local instructionNumber = 0
    if opmode == MODE_iABC then
      local a = twosComplement(instruction[2])
      local b = twosComplement(instruction[3])
      local c = twosComplement(instruction[4])
      instructionNumber = instructionNumber + opcode
      instructionNumber = instructionNumber + (a * 64) -- a << 6
      instructionNumber = instructionNumber + (b * 8388608) -- b << 23
      instructionNumber = instructionNumber + (c * 16384) -- c << 14
    elseif opmode == MODE_iABx then
      local a = twosComplement(instruction[2])
      local b = twosComplement(instruction[3])
      instructionNumber = instructionNumber + opcode
      instructionNumber = instructionNumber + (a * 64) -- a << 6
      instructionNumber = instructionNumber + (b * 16384) -- b << 14
    elseif opmode == MODE_iAsBx then
      local a = twosComplement(instruction[2])
      local b = instruction[3]
      instructionNumber = instructionNumber + opcode
      instructionNumber = instructionNumber + (a * 64) -- a << 6
      instructionNumber = instructionNumber + ((b + 131071) * 16384) -- (b + 131071) << 14
    end
    return makeFourBytes(instructionNumber)
  end
  function makeConstantSection()
    local constantSection = makeFourBytes(#constants) -- Number of constants
    for _, constant in ipairs(constants) do
      local constantType = type(constant)
      constantSection = constantSection .. makeConstant(constant, constantType)
    end
    constantSection = constantSection .. makeFourBytes(#protos) -- Number of protos
    for _, proto in ipairs(protos) do
      constantSection = constantSection .. makeFunction(proto)
    end
    return constantSection
  end
  function makeCodeSection()
    local codeSection = makeFourBytes(#code) -- Number of instructions
    for _, instruction in ipairs(code) do
      codeSection = codeSection .. makeInstruction(instruction)
    end
    return codeSection
  end
  function makeFunction(proto)
    setProto(proto)
    local functionHeader = makeString(functionName) -- Function name
    functionHeader = functionHeader .. makeFourBytes(0) -- Line defined
    functionHeader = functionHeader .. makeFourBytes(0) -- Last line defined
    functionHeader = functionHeader .. makeOneByte(#upvalues) -- nups (Number of upvalues)
    functionHeader = functionHeader .. makeOneByte(numParams) -- Number of parameters
    functionHeader = functionHeader .. makeOneByte((isVarArg and 2) or 0) -- Is vararg
    functionHeader = functionHeader .. makeOneByte(128) -- Max stack size

    functionHeader = functionHeader .. makeCodeSection()
    functionHeader = functionHeader .. makeConstantSection()

    functionHeader = functionHeader .. makeFourBytes(0) -- Line info
    functionHeader = functionHeader .. makeFourBytes(0) -- Local variables
    functionHeader = functionHeader .. makeFourBytes(0) -- Upvalues
    return functionHeader
  end
  function makeHeader()
    local header = "\27Lua" -- Signature
    header = header .. string.char(0x51)  -- Version 5.1
    header = header .. "\0"  -- Format 0 (official)
    header = header .. "\1"  -- Little endian
    header = header .. "\4"  -- sizeof(int)
    header = header .. "\8"  -- sizeof(size_t)
    header = header .. "\4"  -- sizeof(Instruction)
    header = header .. "\8"  -- sizeof(lua_Number)
    header = header .. "\0"  -- Integral flag
    return header
  end

  --// MAIN //--
  local function makeBytecode()
    local header = makeHeader()
    local functionHeader = makeFunction(currentProto)
    return header .. functionHeader
  end
  local function compile()
    newProto()
    processCodeBlock(ast)
    addInstruction("RETURN", 0, 1) -- Default return statement
    return makeBytecode()
  end

  return compile()
end

return {
  Tokenizer = Tokenizer,
  Parser = Parser,
  Compiler = Compiler
}
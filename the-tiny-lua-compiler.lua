--[[

TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE
T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E
T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E
T:::::TT:::::::TT:::::THH::::::H     H::::::HHEE::::::EEEEEEEEE::::E
TTTTTT  T:::::T  TTTTTT  H:::::H     H:::::H    E:::::E       EEEEEE
        T:::::T          H:::::H     H:::::H    E:::::E
        T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE
        T:::::T          H:::::::::::::::::H    E:::::::::::::::E
        T:::::T          H:::::::::::::::::H    E:::::::::::::::E
        T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE
        T:::::T          H:::::H     H:::::H    E:::::E
        T:::::T          H:::::H     H:::::H    E:::::E       EEEEEE
      TT:::::::TT      HH::::::H     H::::::HHEE::::::EEEEEEEE:::::E
      T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E
      T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E
      TTTTTTTTTTT      HHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE

TTTTTTTTTTTTTTTTTTTTTTTIIIIIIIIIINNNNNNNN        NNNNNNNNYYYYYYY       YYYYYYY
T:::::::::::::::::::::TI::::::::IN:::::::N       N::::::NY:::::Y       Y:::::Y
T:::::::::::::::::::::TI::::::::IN::::::::N      N::::::NY:::::Y       Y:::::Y
T:::::TT:::::::TT:::::TII::::::IIN:::::::::N     N::::::NY::::::Y     Y::::::Y
TTTTTT  T:::::T  TTTTTT  I::::I  N::::::::::N    N::::::NYYY:::::Y   Y:::::YYY
        T:::::T          I::::I  N:::::::::::N   N::::::N   Y:::::Y Y:::::Y
        T:::::T          I::::I  N:::::::N::::N  N::::::N    Y:::::Y:::::Y
        T:::::T          I::::I  N::::::N N::::N N::::::N     Y:::::::::Y
        T:::::T          I::::I  N::::::N  N::::N:::::::N      Y:::::::Y
        T:::::T          I::::I  N::::::N   N:::::::::::N       Y:::::Y
        T:::::T          I::::I  N::::::N    N::::::::::N       Y:::::Y
        T:::::T          I::::I  N::::::N     N:::::::::N       Y:::::Y
      TT:::::::TT      II::::::IIN::::::N      N::::::::N       Y:::::Y
      T:::::::::T      I::::::::IN::::::N       N:::::::N    YYYY:::::YYYY
      T:::::::::T      I::::::::IN::::::N        N::::::N    Y:::::::::::Y
      TTTTTTTTTTT      IIIIIIIIIINNNNNNNN         NNNNNNN    YYYYYYYYYYYYY

 LLLLLLLLLLL            UUUUUUUU     UUUUUUUU           AAA
 L:::::::::L            U::::::U     U::::::U          A:::A
 L:::::::::L            U::::::U     U::::::U         A:::::A
 LL:::::::LL            UU:::::U     U:::::UU        A:::::::A
   L:::::L               U:::::U     U:::::U        A:::::::::A
   L:::::L               U:::::D     D:::::U       A:::::A:::::A
   L:::::L               U:::::D     D:::::U      A:::::A A:::::A
   L:::::L               U:::::D     D:::::U     A:::::A   A:::::A
   L:::::L               U:::::D     D:::::U    A:::::A     A:::::A
   L:::::L               U:::::D     D:::::U   A:::::AAAAAAAAA:::::A
   L:::::L               U:::::D     D:::::U  A:::::::::::::::::::::A
   L:::::L         LLLLLLU::::::U   U::::::U A:::::AAAAAAAAAAAAA:::::A
 LL:::::::LLLLLLLLL:::::LU:::::::UUU:::::::UA:::::A             A:::::A
 L::::::::::::::::::::::L UU:::::::::::::UUA:::::A               A:::::A
 L::::::::::::::::::::::L   UU:::::::::UU A:::::A                 A:::::A
 LLLLLLLLLLLLLLLLLLLLLLLL     UUUUUUUUU  AAAAAAA                   AAAAAAA

        CCCCCCCCCCCCC     OOOOOOOOO     MMMMMMMM               MMMMMMMMPPPPPPPPPPPPPPPPP   IIIIIIIIIILLLLLLLLLLL             EEEEEEEEEEEEEEEEEEEEEERRRRRRRRRRRRRRRRR
     CCC::::::::::::C   OO:::::::::OO   M:::::::M             M:::::::MP::::::::::::::::P  I::::::::IL:::::::::L             E::::::::::::::::::::ER::::::::::::::::R
   CC:::::::::::::::C OO:::::::::::::OO M::::::::M           M::::::::MP::::::PPPPPP:::::P I::::::::IL:::::::::L             E::::::::::::::::::::ER::::::RRRRRR:::::R
  C:::::CCCCCCCC::::CO:::::::OOO:::::::OM:::::::::M         M:::::::::MPP:::::P     P:::::PII::::::IILL:::::::LL             EE::::::EEEEEEEEE::::ERR:::::R     R:::::R
 C:::::C       CCCCCCO::::::O   O::::::OM::::::::::M       M::::::::::M  P::::P     P:::::P  I::::I    L:::::L                 E:::::E       EEEEEE  R::::R     R:::::R
C:::::C              O:::::O     O:::::OM:::::::::::M     M:::::::::::M  P::::P     P:::::P  I::::I    L:::::L                 E:::::E               R::::R     R:::::R
C:::::C              O:::::O     O:::::OM:::::::M::::M   M::::M:::::::M  P::::PPPPPP:::::P   I::::I    L:::::L                 E::::::EEEEEEEEEE     R::::RRRRRR:::::R
C:::::C              O:::::O     O:::::OM::::::M M::::M M::::M M::::::M  P:::::::::::::PP    I::::I    L:::::L                 E:::::::::::::::E     R:::::::::::::RR
C:::::C              O:::::O     O:::::OM::::::M  M::::M::::M  M::::::M  P::::PPPPPPPPP      I::::I    L:::::L                 E:::::::::::::::E     R::::RRRRRR:::::R
C:::::C              O:::::O     O:::::OM::::::M   M:::::::M   M::::::M  P::::P              I::::I    L:::::L                 E::::::EEEEEEEEEE     R::::R     R:::::R
C:::::C              O:::::O     O:::::OM::::::M    M:::::M    M::::::M  P::::P              I::::I    L:::::L                 E:::::E               R::::R     R:::::R
 C:::::C       CCCCCCO::::::O   O::::::OM::::::M     MMMMM     M::::::M  P::::P              I::::I    L:::::L         LLLLLL  E:::::E       EEEEEE  R::::R     R:::::R
  C:::::CCCCCCCC::::CO:::::::OOO:::::::OM::::::M               M::::::MPP::::::PP          II::::::IILL:::::::LLLLLLLLL:::::LEE::::::EEEEEEEE:::::ERR:::::R     R:::::R
   CC:::::::::::::::C OO:::::::::::::OO M::::::M               M::::::MP::::::::P          I::::::::IL::::::::::::::::::::::LE::::::::::::::::::::ER::::::R     R:::::R
     CCC::::::::::::C   OO:::::::::OO   M::::::M               M::::::MP::::::::P          I::::::::IL::::::::::::::::::::::LE::::::::::::::::::::ER::::::R     R:::::R
        CCCCCCCCCCCCC     OOOOOOOOO     MMMMMMMM               MMMMMMMMPPPPPPPPPP          IIIIIIIIIILLLLLLLLLLLLLLLLLLLLLLLLEEEEEEEEEEEEEEEEEEEEEERRRRRRRR     RRRRRRR

]]

local function createLookupTable(list)
  local lookup = {}
  for _, value in ipairs(list) do
    lookup[value] = true
  end
  return lookup
end
local function makeTrie(table)
  local trieTable = {}
  for _, op in ipairs(table) do
    local node = trieTable
    for index = 1, #op do
      local character = op:sub(index, index)
      node[character] = node[character] or {}
      node = node[character]
    end
    node.Value = op
  end
  return trieTable
end

--/// Tokenizer ///--
local TOKENIZER_LUA_OPERATORS = {
  "^", "*", "/", "%",
  "+", "-", "<", ">",
  "#",

  "<=",  ">=", "==",  "~=",
  "and", "or", "not", ".."
}
local TOKENIZER_ESCAPED_CHARACTER_CONVERSIONS = {
  ["a"]     = "\a", -- bell
  ["b"]     = "\b", -- backspace
  ["f"]     = "\f", -- form feed
  ["n"]     = "\n", -- newline
  ["r"]     = "\r", -- carriage return
  ["t"]     = "\t", -- horizontal tab
  ["v"]     = "\v", -- vertical tab

  [ "\\" ] = "\\",   -- backslash
  [ "\"" ] = "\"",  -- double quote
  [ "\'" ] = "\'",  -- single quote
}

local TOKENIZER_LUA_CONSTANTS_LOOKUP     = createLookupTable({ "true", "false", "nil" })
local TOKENIZER_RESERVED_KEYWORDS_LOOKUP = createLookupTable({
"while",    "do",     "end",   "for",
"local",    "repeat", "until", "return",
"in",       "if",     "else",  "elseif",
"function", "then",   "break", "continue" })
local TOKENIZER_LUA_OPERATORS_LOOKUP = createLookupTable(TOKENIZER_LUA_OPERATORS)
local TOKENIZER_OPERATOR_TRIE        = makeTrie(TOKENIZER_LUA_OPERATORS)

--* Tokenizer *--
local Tokenizer = {}
function Tokenizer.tokenize(code)
  local charStream, charStreamLen = {}, 0
  for char in code:gmatch(".") do
    charStreamLen = charStreamLen + 1
    charStream[charStreamLen] = char
  end

  local charStream = charStream
  local curCharPos = 1
  local curChar = charStream[curCharPos]

  --// CHARACTER NAVIGATION //--
  local function lookAhead(n)
    local updatedCharPos = curCharPos + (n or 1)
    local updatedChar    = charStream[updatedCharPos] or "\0"
    return updatedChar
  end
  local function consume(n)
    local updatedCharPos = curCharPos + (n or 1)
    local updatedChar    = charStream[updatedCharPos] or "\0"
    curCharPos = updatedCharPos
    curChar    = updatedChar
    return updatedChar
  end

  --// CHECKERS //--
  local function isWhitespace(char)
    local char = char or curChar
    return char:match("%s")
  end
  local function isNumberStart(char)
    local char = char or curChar
    return char:match("%d")
  end
  local function isNumber(char)
    local char = char or curChar
    return char:match("%d")
  end
  local function isIdentifier(char)
    local char = char or curChar
    return char:match("[%a%d_]")
  end
  local function isIdentifierStart(char)
    local char = char or curChar
    return char:match("[%a_]")
  end
  local function isScientificNotationPrefix(char)
    local char = char or curChar
    return char == "e" or char == "E"
  end
  local function isHexadecimalNumberPrefix()
    return curChar == "0" and (lookAhead() == "x" or lookAhead() == "X")
  end
  local function isVarArg()
    return curChar == "." and lookAhead(1) == "." and lookAhead(2) == "."
  end
  local function isComment()
    return curChar == "-" and lookAhead(1) == "-"
  end
  local function isString()
    return (curChar == '"' or curChar == "'")
        or (curChar == "[" and (lookAhead(1) == "[" or lookAhead(1) == "="))
  end

  --// CONSUMERS //--
  local function consumeWhitespace()
    local whitespace = { curChar }
    while isWhitespace(lookAhead()) do
      table.insert(whitespace, curChar)
      consume()
    end
    return table.concat(whitespace)
  end
  local function consumeIdentifier()
    local identifier = { curChar }
    while isIdentifier(lookAhead()) do
      table.insert(identifier, consume())
    end
    return table.concat(identifier)
  end
  local function consumeInteger(maxLength)
    local integer = { curChar }
    while lookAhead():match("%d") do
      if (maxLength and #integer >= maxLength) then break end
      table.insert(integer, consume())
    end
    return table.concat(integer)
  end
  local function consumeNumber()
    local number = { curChar }

    -- Hexadecimal number case
    -- 0[xX][0-9a-fA-F]+
    if isHexadecimalNumberPrefix() then
      table.insert(number, consume()) -- Consume the "0"
      table.insert(number, consume()) -- Consume the "x"
      while isNumber(lookAhead()) or lookAhead():match("[a-fA-F]") do
        table.insert(number, consume())
      end
      return table.concat(number)
    end

    while isNumber(lookAhead()) do
      table.insert(number, consume())
    end

    -- Floating point number case
    -- [0-9]*\.[0-9]+
    if lookAhead() == "." then
      table.insert(number, consume()) -- Consume the "."
      while isNumber(lookAhead()) do
        table.insert(number, consume())
      end
    end

    -- Exponential (scientific) notation case
    -- [eE][+-]?[0-9]+
    if isScientificNotationPrefix(lookAhead()) then
      table.insert(number, consume()) -- Consume the "e" or "E"
      if lookAhead() == "+" or lookAhead() == "-" then -- Consume optional sign
        table.insert(number, consume())
      end
      while isNumber(lookAhead()) do
        table.insert(number, consume())
      end
    end

    return table.concat(number)
  end
  local function consumeSimpleString()
    local delimiter = curChar
    local newString = { }
    consume() -- Consume the delimiter
    while curChar ~= delimiter do
      if curChar == "\\" then
        local nextChar = consume()
        if nextChar:match("%d") then -- Numeric escape sequence?
          local number = consumeInteger(3)
          table.insert(newString, string.char(tonumber(number)))
        elseif TOKENIZER_ESCAPED_CHARACTER_CONVERSIONS[nextChar] then
          table.insert(newString, TOKENIZER_ESCAPED_CHARACTER_CONVERSIONS[nextChar])
        else
          error("invalid escape sequence near '\\" .. nextChar .. "'")
        end
      else
        table.insert(newString, curChar)
      end
      consume()
    end
    return table.concat(newString)
  end
  local function consumeLongString()
    consume() -- Consume the "[" character
    local depth = 0
    local content = ""
    while curChar == "=" do
      consume() -- Consume the "=" character
      depth = depth + 1
    end
    if curChar ~= "[" then
      error("invalid long string delimiter")
    end
    consume() -- Consume the "[" character
    while true do
      if curChar == "]" then
        consume() -- Consume the "]" character
        local closingDepth = 0
        while curChar == "=" do
          consume() -- Consume the "=" character
          closingDepth = closingDepth + 1
        end
        if closingDepth == depth and curChar == "]" then
          break -- Exit the loop, as the closing delimiter is fully matched
        end
        -- If it's not a valid closing delimiter, add the "]" and "=" characters to content
        content = content .. "]" .. string.rep("=", closingDepth)
      elseif curChar == "\0" then
        error("Unclosed long comment")
      end

      content = content .. curChar
      consume()
    end
    return content
  end
  local function consumeString()
    if curChar == "[" then
      return consumeLongString()
    end
    return consumeSimpleString()
  end
  local function consumeOperator()
    local node  = TOKENIZER_OPERATOR_TRIE
    local operator

    -- Trie walker
    local index = 0
    while true do
      local character = lookAhead(index)
      node = node[character] -- Advance to the deeper node
      if not node then break end
      operator = node.Value
      index    = index + 1
    end
    if operator then
      consume(#operator - 1)
    end

    return operator
  end
  local function consumeShortComment()
    while curChar ~= "\0" and curChar ~= "\n" do
      consume()
    end
  end
  local function consumeLongComment()
    consume() -- Consumes the "[" character
    local depth = 0
    while curChar == "=" do
      consume() -- Consume the "=" character
      depth = depth + 1
    end
    if curChar ~= "[" then return consumeShortComment() end
    while true do
      if curChar == "]" then
        consume() -- Consume the "]" character
        local closingDepth = 0
        while curChar == "=" do
          consume() -- Consume the "=" character
          closingDepth = closingDepth + 1
        end
        if closingDepth == depth then break end
      elseif curChar == "\0" then
        error("Unclosed long comment")
      end
      consume()
    end
  end
  local function consumeComment()
    consume() -- Consume the "-" character
    consume() -- Consume the "-" character
    if curChar == "[" then
      return consumeLongComment()
    end
    return consumeShortComment()
  end

  --// TOKENIZERS //--
  local function getNextToken()
    local curChar = curChar
    if isWhitespace(curChar) then
      consumeWhitespace()
      return
    elseif isComment() then
      consumeComment()
      return
    elseif isNumberStart(curChar) then
      return { TYPE = "Number", Value = tonumber(consumeNumber()) }
    elseif isIdentifierStart(curChar) then
      local identifier = consumeIdentifier()
      if TOKENIZER_LUA_OPERATORS_LOOKUP[identifier] then
        return { TYPE = "Operator", Value = identifier }
      elseif TOKENIZER_RESERVED_KEYWORDS_LOOKUP[identifier] then
        return { TYPE = "Keyword", Value = identifier }
      elseif TOKENIZER_LUA_CONSTANTS_LOOKUP[identifier] then
        return { TYPE = "Constant", Value = identifier }
      else
        return { TYPE = "Identifier", Value = identifier }
      end
    elseif isString(curChar) then
      return { TYPE = "String", Value = consumeString() }
    elseif isVarArg() then
      consume(2)
      return { TYPE = "VarArg" }
    end

    local operator = consumeOperator()
    if operator then
      return { TYPE = "Operator", Value = operator }
    end
    return { TYPE = "Character", Value = curChar }
  end

  --// MAIN //--
  local function tokenize()
    local tokens = {}
    while curChar ~= "\0" do
      local token = getNextToken()
      if token then
        table.insert(tokens, token)
      end
      consume()
    end
    return tokens
  end

  return tokenize()
end

--/// Parser ///--
local PARSER_UNARY_OPERATOR_PRECEDENCE = 8
local PARSER_STOP_KEYWORDS       = createLookupTable({ "end", "else", "elseif", "until" })
local PARSER_OPERATOR_PRECEDENCE = { ["+"]   = {6, 6},  ["-"]  = {6, 6},
                                     ["*"]   = {7, 7},  ["/"]  = {7, 7}, ["%"] = {7, 7},
                                     ["^"]   = {10, 9}, [".."] = {5, 4},
                                     ["=="]  = {3, 3},  ["~="] = {3, 3},
                                     ["<"]   = {3, 3},  [">"]  = {3, 3}, ["<="] = {3, 3}, [">="] = {3, 3},
                                     ["and"] = {2, 2},  ["or"] = {1, 1} }
local PARSER_LUA_UNARY_OPERATORS  = createLookupTable({ "-", "#", "not" })
local PARSER_LUA_BINARY_OPERATORS = createLookupTable({ "+",  "-",   "*",  "/",
                                      "%",  "^",   "..", "==",
                                      "~=", "<",   ">",  "<=",
                                      ">=", "and", "or" })

--* Parser *--
local Parser = {}
function Parser.parse(tokens)
  local tokens            = tokens
  local currentToken      = tokens[1]
  local currentTokenIndex = 1
  local scopeStack        = {}
  local currentScope      = {}

  --// TOKEN NAVIGATION //--
  local function lookAhead(n)
    local updatedTokenIndex = currentTokenIndex + (n or 1)
    local updatedToken      = tokens[updatedTokenIndex]
    return updatedToken
  end
  local function consume(n)
    local updatedTokenIndex = currentTokenIndex + (n or 1)
    local updatedToken      = tokens[updatedTokenIndex]
    currentTokenIndex = updatedTokenIndex
    currentToken      = updatedToken
    return updatedToken
  end

  --// SCOPE MANAGEMENT //--
  local function enterScope(isFunctionScope)
    local scope = {
      localVariables = {},
      isFunctionScope = isFunctionScope
    }
    table.insert(scopeStack, scope)
    currentScope = scope
    return scope
  end
  local function exitScope()
    scopeStack[#scopeStack] = nil
    currentScope = scopeStack[#scopeStack]
  end

  --// IN-SCOPE VARIABLE MANAGEMENT //--
  local function declareLocalVariable(variable)
    currentScope.localVariables[variable] = true
  end
  local function declareLocalVariables(variables)
    for _, variable in ipairs(variables) do
      declareLocalVariable(variable)
    end
  end
  local function getVariableType(variableName)
    local isUpvalue = false
    for scopeIndex = #scopeStack, 1, -1 do
      local scope = scopeStack[scopeIndex]
      if scope.localVariables[variableName] then
        local variableType = (isUpvalue and "Upvalue") or "Local"
        return variableType, scopeIndex
      elseif scope.isFunctionScope then
        isUpvalue = true
      end
    end
    return "Global"
  end

  --// TOKEN CHECKERS //--
  local function checkToken(tokenType, tokenValue, token)
    local token = token or currentToken
    return token
          and token.TYPE  == tokenType
          and token.Value == tokenValue
  end
  local function isComma(token)
    return token and token.TYPE == "Character" and token.Value == ","
  end
  local function isUnaryOperator(token)
    return token and token.TYPE == "Operator" and PARSER_LUA_UNARY_OPERATORS[token.Value]
  end
  local function isBinaryOperator(token)
    return token and token.TYPE == "Operator" and PARSER_LUA_BINARY_OPERATORS[token.Value]
  end

  --// NODE CHECKERS //--
  local function isValidAssignmentLvalue(node)
    local nodeType = node.TYPE
    return nodeType == "Variable" or nodeType == "TableIndex"
  end
  local function isMultiretNode(node)
    local nodeType = node.TYPE
    return nodeType == "FunctionCall" or nodeType == "MethodCall" or nodeType == "VarArg"
  end

  --// EXPECTORS //--
  local function expectToken(expectedType, expectedValue, skipConsume)
    local actualType = currentToken and currentToken.TYPE or "nil"
    assert(currentToken and currentToken.TYPE == expectedType, "Expected a " .. expectedType .. ", got: " .. actualType)
    assert(currentToken.Value == expectedValue, "Expected '" .. expectedValue .. "'")
    if not skipConsume then consume() end
  end
  local function expectTokenType(expectedType, skipConsume)
    local actualType = currentToken and currentToken.TYPE or "nil"
    assert(actualType == expectedType, string.format("Expected a %s, got: %s", expectedType, actualType))
    if not skipConsume then consume() end
  end
  local function expectCharacter(character, skipConsume)
    local actualType = currentToken and currentToken.TYPE or "nil"
    assert(currentToken and currentToken.TYPE == "Character", "Expected a character, got: " .. actualType)
    assert(currentToken.Value == character, "Expected '" .. character .. "'")
    if not skipConsume then consume() end
  end
  local function expectKeyword(keyword, skipConsume)
    local actualType = currentToken and currentToken.TYPE or "nil"
    assert(currentToken and currentToken.TYPE == "Keyword", "Expected a keyword, got: " .. actualType)
    assert(currentToken.Value == keyword, "Expected '" .. keyword .. "'")
    if not skipConsume then consume() end
  end

  --// AUXILIARY FUNCTIONS //--
  local function createNilNode()
    return { TYPE = "Constant", Value = "nil" }
  end
  local function adjustMultiretNodes(nodeList, expectedReturnAmount)
    local lastNode = nodeList[#nodeList]
    local extraReturns = expectedReturnAmount - #nodeList
    if lastNode and isMultiretNode(lastNode) then
      extraReturns = math.max(extraReturns + 1, -1)
      -- Adjust the return value amount
      lastNode.ReturnValueAmount = extraReturns
    else
      for _ = 1, extraReturns do
        table.insert(nodeList, createNilNode())
      end
    end
  end

  --// PARSERS //--
  local getNextNode, parseCodeBlock
  local consumeExpression, consumeExpressions
  local function consumeIdentifierList()
    local identifiers = {}
    while currentToken.TYPE == "Identifier" do
      table.insert(identifiers, currentToken.Value)
      if not isComma(lookAhead()) then break end
      consume() -- Consume identifier
      consume() -- Consume comma
    end
    return identifiers
  end
  local function consumeParameterList()
    expectCharacter("(")
    local parameters, isVarArg = {}, false
    while not checkToken("Character", ")") do
      if currentToken.TYPE == "Identifier" then
        table.insert(parameters, currentToken.Value)
      elseif currentToken.TYPE == "VarArg" then
        isVarArg = true
        consume() -- Consume the "..."
        break
      end
      consume() -- Consume the last token of the parameter
      if not isComma(currentToken) then break end
      consume() -- Consume the comma
    end
    expectCharacter(")")
    return parameters, isVarArg
  end
  local function consumeTableIndex(currentExpression)
    consume() -- Consume the "." symbol
    local indexToken = { TYPE = "String", Value = currentToken.Value }
    return { TYPE = "TableIndex", Index = indexToken, Expression = currentExpression }
  end
  local function consumeBracketTableIndex(currentExpression)
    consume() -- Consume the "[" symbol
    local indexExpression = consumeExpression()
    consume() -- Consume the last token of the index expression
    expectCharacter("]", true)
    return { TYPE = "TableIndex", Index = indexExpression, Expression = currentExpression }
  end
  local function consumeTable()
    consume() -- Consume the "{" symbol
    local implicitElements = {}
    local explicitElements = {}
    local lastImplicitElement
    local internalImplicitKey = 1

    -- Consume table elements
    while not checkToken("Character", "}") do
      local key, value
      local isImplicitKey = false

      -- [<expression>] = <expression>
      if checkToken("Character", "[") then
        consume() -- Consume "["
        key = consumeExpression()
        consume() -- Consume the last token of the key
        expectCharacter("]")
        expectCharacter("=")
        value = consumeExpression()

      -- <identifier> = <expression>
      elseif currentToken.TYPE == "Identifier" and checkToken("Character", "=", lookAhead()) then
        key = { TYPE = "String", Value = currentToken.Value }
        consume() -- Consume key
        consume() -- Consume "="
        value = consumeExpression()

      -- <expression>
      else
        key = { TYPE = "Number", Value = internalImplicitKey }
        internalImplicitKey = internalImplicitKey + 1
        isImplicitKey = true
        value = consumeExpression()
      end
      local element = { Key = key, Value = value }
      local tableToInsert = (isImplicitKey and implicitElements) or explicitElements
      table.insert(tableToInsert, element)

      consume() -- Consume the last token of the expression
      local shouldContinue = checkToken("Character", ",")
      if not shouldContinue then break end
      consume() -- Consume ","
    end
    local lastImplicitElement = implicitElements[#implicitElements]
    if lastImplicitElement then
      local lastImplicitElementTableValue = lastImplicitElement.Value.Value
      if isMultiretNode(lastImplicitElementTableValue) then
        lastImplicitElementTableValue.ReturnValueAmount = -1
      end
    end

    return { TYPE = "Table",
      ImplicitElements = implicitElements,
      ExplicitElements = explicitElements }
  end
  local function consumeFunctionCall(currentExpression)
    consume() -- Consume the "("
    local arguments = consumeExpressions()
    adjustMultiretNodes(arguments, -1)
    consume() -- Consume the last token of the expression
    return { TYPE = "FunctionCall", Expression = currentExpression, Arguments = arguments, ReturnValueAmount = 1 }
  end
  local function consumeMethodCall(currentExpression)
    local methodIdentifier = consume().Value -- Consume the ":" character, and get the method identifier
    consume() -- Consume the method identifier
    local methodIndexNode = { TYPE = "TableIndex", Index = { TYPE = "String", Value = methodIdentifier }, Expression = currentExpression }
    local functionCallNode = consumeFunctionCall(methodIndexNode)
    functionCallNode.TYPE = "MethodCall"
    return functionCallNode
  end
  local function consumeOptionalSemilcolon()
    local nextToken = lookAhead()
    if checkToken("Character", ";", nextToken) then
      consume()
    end
  end

  --// EXPRESSSION PARSERS //--
  local parsePrimaryExpression, parseSuffixExpression,
        parsePrefixExpression,  parseUnaryOperator,
        parseBinaryExpression
  function parsePrimaryExpression()
    if not currentToken then return end
    local tokenType = currentToken.TYPE
    local tokenValue = currentToken.Value

    if tokenType == "Number" or tokenType == "String"
     or tokenType == "Constant" or tokenType == "VarArg" then
      return currentToken
    elseif tokenType == "Identifier" then
      local variableType = getVariableType(tokenValue)
      local variableNode = { TYPE = "Variable", Value = tokenValue, VariableType = variableType }
      return variableNode
    elseif tokenType == "Character" then
      if tokenValue == "(" then -- Parenthesized expression
        consume() -- Consume the parenthesis
        local expression = consumeExpression()
        consume() -- Consume the last token of the expression
        return expression
      elseif tokenValue == "{" then -- Table constructor
        return consumeTable()
      end
    elseif tokenType == "Keyword" then
      if tokenValue == "function" then
        consume() -- Consume the "function" token
        local parameters, isVarArg = consumeParameterList()
        local codeblock = parseCodeBlock(true, parameters)
        expectKeyword("end", true)
        return { TYPE = "Function", Codeblock = codeblock, Parameters = parameters, IsVarArg = isVarArg }
      end
    end
    return nil
  end
  function parseSuffixExpression(primaryExpression)
    local nextToken = lookAhead()
    local nextTokenValue = nextToken and nextToken.Value
    if nextTokenValue == "(" then -- Function call
      consume()
      -- <expression> \( <args> \)
      return consumeFunctionCall(primaryExpression)
    elseif nextTokenValue == "." then -- Table access
      consume()
      -- <expression> \. <identifier>
      return consumeTableIndex(primaryExpression)
    elseif nextTokenValue == ":" then -- Method call
      consume()
      -- <expression> \: <identifier> \( <args> \)
      return consumeMethodCall(primaryExpression)
    elseif nextTokenValue == "[" then -- Table index
      consume()
      -- <expression> \[ <expression> \]
      return consumeBracketTableIndex(primaryExpression)
    end
    return nil
  end
  function parsePrefixExpression(precedence)
    local primaryExpression = parsePrimaryExpression(precedence) -- <primary>
    if not primaryExpression then return end

    -- <suffix>*
    while (true) do
      local newExpression = parseSuffixExpression(primaryExpression)
      if not newExpression then break end
      primaryExpression = newExpression
    end

    return primaryExpression
  end
  function parseUnaryOperator()
    local unaryOperator = currentToken
    -- <unary> ::= <unary operator> <unary> | <primary>
    if not isUnaryOperator(currentToken) then
      return parsePrefixExpression(PARSER_UNARY_OPERATOR_PRECEDENCE)
    end

    -- <unary operator> <unary>
    consume() -- Consume the operator
    local expression = parseBinaryExpression(PARSER_UNARY_OPERATOR_PRECEDENCE)
    return { TYPE = "UnaryOperator", Operator = unaryOperator.Value, Operand = expression }
  end
  function parseBinaryExpression(minPrecedence)
    -- <binary> ::= <unary> <binary operator> <binary> | <unary>
    local minPrecedence = minPrecedence or 0
    local expression = parseUnaryOperator() -- <unary>
    if not expression then return end

    -- [<binary operator> <binary>]
    while true do
      local operatorToken = lookAhead()
      local precedence = operatorToken and PARSER_OPERATOR_PRECEDENCE[operatorToken.Value]
      if not isBinaryOperator(operatorToken) or precedence[1] <= minPrecedence then
        break
      end

      -- The <binary operator> <binary> part itself
      local nextToken = consume(2) -- Advance to and consume the operator
      if not nextToken then error("Unexpected end") end

      local right = parseBinaryExpression(precedence[2])
      if not right then error("Unexpected end") end

      expression = { TYPE = "BinaryOperator",
        Operator = operatorToken.Value,
        Left = expression, Right = right }
    end
    return expression
  end
  function consumeExpression(returnRawNode)
    local expression = parseBinaryExpression(0)
    if not expression then
      consume(-1)
      return
    end
    if returnRawNode then return expression end
    return { TYPE = "Expression", Value = expression }
  end
  function consumeExpressions()
    local expressions = { consumeExpression(true) }
    if #expressions == 0 then return {} end

    local nextToken = lookAhead()
    while isComma(nextToken) do
      consume(2) -- Consume the last token of the last expression and ","
      local expression = consumeExpression(true)
      table.insert(expressions, expression)
      nextToken = lookAhead()
    end

    return expressions
  end

  --// STATEMENT PARSERS //--
  local function parseLocal()
    consume() -- Consume the "local" token
    if checkToken("Keyword", "function") then
      consume() -- Consume the "function" token
      local name = currentToken.Value
      consume() -- Consume the last token of the identifier)
      local parameters, isVarArg = consumeParameterList()
      declareLocalVariable(name)
      local codeblock = parseCodeBlock(true, parameters)
      expectKeyword("end", true)
      return { TYPE = "LocalFunctionDeclaration", Name = name, Codeblock = codeblock, Parameters = parameters, IsVarArg = isVarArg }
    end
    local variables = consumeIdentifierList()
    if checkToken("Character", "=", lookAhead()) then
      consume() -- Consume the last token of the last identifier
      expectCharacter("=")
      local expressions = consumeExpressions()
      adjustMultiretNodes(expressions, #variables)
      declareLocalVariables(variables)
      return { TYPE = "LocalDeclaration", Variables = variables, Expressions = expressions }
    end
    declareLocalVariables(variables)
    return { TYPE = "LocalDeclaration", Variables = variables, Expressions = {} }
  end
  local function parseWhile()
    consume() -- Consume the "while" token
    local condition = consumeExpression()
    consume() -- Consume the last token of the condition
    expectKeyword("do")
    local codeblock = parseCodeBlock()
    expectKeyword("end", true)
    return { TYPE = "WhileLoop", Condition = condition, Codeblock = codeblock }
  end
  local function parseRepeat()
    consume() -- Consume the "repeat" token
    local codeblock = parseCodeBlock()
    expectKeyword("until")
    local condition = consumeExpression()
    return { TYPE = "RepeatLoop", Codeblock = codeblock, Condition = condition }
  end
  local function parseDo()
    consume() -- Consume the "do" token
    local codeblock = parseCodeBlock()
    expectKeyword("end", true)
    return { TYPE = "DoBlock", Codeblock = codeblock }
  end
  local function parseReturn()
    consume() -- Consume the "return" token
    local expressions = consumeExpressions()
    adjustMultiretNodes(expressions, -1)
    return { TYPE = "ReturnStatement", Expressions = expressions }
  end
  local function parseBreak()
    return { TYPE = "BreakStatement" }
  end
  local function parseIf()
    consume() -- Consume the "if" token
    local condition = consumeExpression()
    consume() -- Consume the last token of the condition
    expectKeyword("then")
    local codeblock = parseCodeBlock()
    local elseifs = {}
    while checkToken("Keyword", "elseif") do
      consume() -- Consume the "elseif" token
      local elseifCondition = consumeExpression()
      consume() -- Consume the last token of the condition
      expectKeyword("then")
      local elseifCodeblock = parseCodeBlock()
      table.insert(elseifs, { Condition = elseifCondition, Codeblock = elseifCodeblock })
    end
    local elseCodeblock
    if checkToken("Keyword", "else") then
      consume() -- Consume the "else" token
      elseCodeblock = parseCodeBlock()
    end
    expectKeyword("end", true)
    return { TYPE = "IfStatement", Condition = condition, Codeblock = codeblock, ElseIfs = elseifs, ElseCodeblock = elseCodeblock }
  end
  local function parseFor()
    consume() -- Consume the "for" token
    expectTokenType("Identifier", true)
    local variableName = currentToken.Value
    consume() -- Consume the variable name
    if checkToken("Character", ",") or checkToken("Keyword", "in") then
      local iteratorVariables = { variableName }
      while checkToken("Character", ",") do
        consume() -- Consume the comma
        expectTokenType("Identifier", true)
        local newVariableName = currentToken.Value
        table.insert(iteratorVariables, newVariableName)
        consume() -- Consume the variable name
      end
      expectKeyword("in")
      local expressions = consumeExpressions()
      adjustMultiretNodes(expressions, 3)
      consume() -- Consume the last token of the expressions
      expectKeyword("do")
      local codeblock = parseCodeBlock(false, iteratorVariables)
      expectKeyword("end", true)
      return { TYPE = "GenericForLoop", IteratorVariables = iteratorVariables, Expressions = expressions, Codeblock = codeblock }
    end
    expectCharacter("=")
    local expressions = consumeExpressions()
    consume() -- Consume the last token of the expressions
    expectKeyword("do")
    local codeblock = parseCodeBlock(false, { variableName })
    expectKeyword("end", true)
    return { TYPE = "NumericForLoop", VariableName = variableName, Expressions = expressions, Codeblock = codeblock }
  end
  local function parseFunction()
    consume() -- Consume the "function" token
    expectTokenType("Identifier", true)
    local variableName = currentToken.Value
    local variableType = getVariableType(variableName)
    local expression = { TYPE = "Variable", Value = variableName, VariableType = variableType }
    local fields, isMethod = { }, false
    while consume() do
      if checkToken("Character", ".") then
        consume() -- Consume the "."
        expectTokenType("Identifier", true)
        local fieldName = currentToken.Value
        table.insert(fields, fieldName)
      elseif checkToken("Character", ":") then
        consume() -- Consume the ":"
        expectTokenType("Identifier", true)
        local methodName = currentToken.Value
        table.insert(fields, methodName)
        isMethod = true
        consume() -- Consume the method name
        break
      else break end
    end
    local parameters, isVarArg = consumeParameterList()
    local codeblock = parseCodeBlock(true, parameters)
    expectKeyword("end", true)
    return { TYPE = "FunctionDeclaration",
      Expression = expression,
      Fields = fields,
      IsMethod = isMethod,
      Codeblock = codeblock,
      Parameters = parameters,
      IsVarArg = isVarArg
    }
  end
  local function parseAssignment(lvalue)
    local lvalues = { lvalue }
    consume() -- Consume the last token of the lvalue
    while isComma(currentToken) do
      consume() -- Consume the comma
      local nextLValue = parsePrefixExpression()
      if not nextLValue then error("Expected an lvalue") end
      if not isValidAssignmentLvalue(nextLValue) then
        error("Expected a variable or index, got: " .. nextLValue.TYPE)
      end
      table.insert(lvalues, nextLValue)
      consume() -- Consume the last token of the lvalue
    end
    expectCharacter("=")
    local expressions = consumeExpressions()
    adjustMultiretNodes(expressions, #lvalues)
    return { TYPE = "VariableAssignment", LValues = lvalues, Expressions = expressions }
  end
  local function parseFunctionCallOrVariableAssignment()
    local lvalue = parsePrefixExpression()
    local lvalueType = tostring(lvalue and lvalue.TYPE)
    if lvalue then
      if isValidAssignmentLvalue(lvalue) then
        return parseAssignment(lvalue)
      elseif lvalueType == "FunctionCall" or lvalueType == "MethodCall" then
        lvalue.ReturnValueAmount = 0
        return lvalue
      end
      error("Unexpected lvalue type: " .. lvalueType)
    end
    error("Expected an lvalue, got: " .. lvalueType)
  end

  --// CODE BLOCK PARSERS //--
  function getNextNode()
    local currentTokenValue = currentToken.Value
    local currentTokenType = currentToken.TYPE
    if currentTokenType == "Keyword" then
      local node
      if PARSER_STOP_KEYWORDS[currentTokenValue] then return
      elseif currentTokenValue == "local"        then node = parseLocal()
      elseif currentTokenValue == "while"        then node = parseWhile()
      elseif currentTokenValue == "repeat"       then node = parseRepeat()
      elseif currentTokenValue == "do"           then node = parseDo()
      elseif currentTokenValue == "return"       then node = parseReturn()
      elseif currentTokenValue == "break"        then node = parseBreak()
      elseif currentTokenValue == "if"           then node = parseIf()
      elseif currentTokenValue == "for"          then node = parseFor()
      elseif currentTokenValue == "function"     then node = parseFunction()
      else error("Unsupported keyword: " .. currentTokenValue) end
      consumeOptionalSemilcolon()
      return node
    end

    local node = parseFunctionCallOrVariableAssignment()
    consumeOptionalSemilcolon()
    return node
  end
  function parseCodeBlock(isFunctionScope, variablesInCodeblock)
    enterScope(isFunctionScope)
    if variablesInCodeblock then
      declareLocalVariables(variablesInCodeblock)
    end
    local nodeList = { TYPE = "Group" }
    while currentToken do
      local node = getNextNode()
      if not node then break end
      table.insert(nodeList, node)
      consume()
    end
    exitScope()
    return nodeList
  end

  --// MAIN //--
  local function parse()
    local ast = parseCodeBlock()
    ast.TYPE = "AST"
    return ast
  end

  return parse()
end

--// Compiler //--
local unpack = (unpack or table.unpack)

local COMPILER_SIMPLE_ARICHMETIC_OPERATOR_LOOKUP = {
  ["+"] = "ADD", ["-"] = "SUB",
  ["*"] = "MUL", ["/"] = "DIV",
  ["%"] = "MOD", ["^"] = "POW"
}
local COMPILER_UNARY_OPERATOR_LOOKUP = { ["-"] = "UNM", ["#"] = "LEN", ["not"] = "NOT" }
local COMPILER_COMPARISON_INSTRUCTION_LOOKUP = {
  ["=="] = {"EQ", 1}, ["~="] = {"EQ", 0},
  ["<"]  = {"LT", 1}, [">"]  = {"LT", 1},
  ["<="] = {"LE", 1}, [">="] = {"LE", 1}
}
local COMPILER_COMPARISON_OPERATOR_LOOKUP = createLookupTable({"==", "~=", "<", ">", "<=", ">="})
local COMPILER_CONTROL_FLOW_OPERATOR_LOOKUP = createLookupTable({"and", "or"})

--* InstructionGenerator *--
local InstructionGenerator = {}
function InstructionGenerator.generate(ast)
  local breakInstructions
  local locals, currentScope
  local scopes = {}
  local currentProto
  local takenRegisters, code, constants,
        constantLookup, upvalues, upvalueLookup,
        protos, numParams, isVarArg, functionName

  --// PROTO MANAGEMENT //--
  local function setProto(proto)
    currentProto   = proto
    takenRegisters = proto.takenRegisters
    code           = proto.code
    constants      = proto.constants
    constantLookup = proto.constantLookup
    upvalues       = proto.upvalues
    upvalueLookup  = proto.upvalueLookup
    protos         = proto.protos
    numParams      = proto.numParams
    isVarArg       = proto.isVarArg
    functionName   = proto.functionName
  end
  local function newProto()
    currentProto = {
      takenRegisters = {},
      code           = {},
      constants      = {},
      constantLookup = {},
      upvalues       = {},
      upvalueLookup  = {},
      protos         = {},
      numParams      = 0,
      isVarArg       = false,
      functionName   = "@tlc",
    }
    setProto(currentProto)
    return currentProto
  end

  --// REGISTER MANAGEMENT //--
  local function allocateRegister()
    for i = 0, 255 do
      if not takenRegisters[i] then
        takenRegisters[i] = true
        return i
      end
    end
    error("Out of registers")
  end
  local function deallocateRegister(register)
    takenRegisters[register] = nil
  end
  local function deallocateRegisters(registers)
    for _, register in ipairs(registers) do
      takenRegisters[register] = nil
    end
  end

  --// VARIABLE MANAGEMENT //--
  local function getVariableType(variableName)
    local scope = currentScope
    local isUpvalue = false
    while scope do
      if scope.locals[variableName] then
        return (isUpvalue and "Upvalue") or "Local"
      elseif scope.isFunctionScope then
        isUpvalue = true
      end
      scope = scope.previousScope
    end
    return "Global"
  end
  local function findVariableRegister(localName)
    local scope = currentScope
    while scope do
      local variableRegister = scope.locals[localName]
      if variableRegister then
        return variableRegister
      elseif scope.isFunctionScope then
        break
      end
      local previousScope = scope.previousScope
      scope = previousScope
    end
    error("Could not find variable: " .. localName)
    return nil
  end
  local function registerVariable(localName, register)
    locals[localName] = register
  end
  local function unregisterVariable(localName)
    deallocateRegister(locals[localName])
    locals[localName] = nil
  end
  local function unregisterVariables(variables)
    for _, variable in ipairs(variables) do
      unregisterVariable(variable)
    end
  end

  --// SCOPE MANAGEMENT //--
  local function enterScope(isFunctionScope)
    local newScope = {
      locals = {},
      isFunctionScope = isFunctionScope,
      previousScope = scopes[#scopes]
    }
    locals = newScope.locals
    table.insert(scopes, newScope)
    currentScope = newScope
    return newScope
  end
  local function exitScope()
    table.remove(scopes)
    for variableName, register in pairs(currentScope.locals) do
      unregisterVariable(variableName)
    end
    if #scopes > 0 then
      currentScope = scopes[#scopes]
      locals = currentScope.locals
    end
  end

  --// UTILITY FUNCTIONS //--
  local function isMultiretNode(node)
    if not node then return false end
    local nodeType = node.TYPE
    return nodeType == "FunctionCall" or nodeType == "MethodCall" or nodeType == "VarArg"
  end
  local function updateBreakInstructions(list)
    local currentInstructionIndex = #code
    for _, breakInstructionIndex in ipairs(list) do
      local instruction  = code[breakInstructionIndex]
      local jumpDistance = currentInstructionIndex - breakInstructionIndex
      instruction[3] = jumpDistance
    end
  end
  local function findOrCreateConstant(value)
    if constantLookup[value] then
      return constantLookup[value]
    end
    table.insert(constants, value)
    local constantIndex = -(#constants)
    constantLookup[value] = constantIndex
    return constantIndex
  end
  local function findOrCreateUpvalue(value)
    if upvalueLookup[value] then
      return upvalueLookup[value]
    end
    table.insert(upvalues, value)
    local upvalueIndex = #upvalues - 1
    upvalueLookup[value] = upvalueIndex
    return upvalueIndex
  end
  local function addInstruction(opname, a, b, c)
    local instruction = { opname, a, b, c }
    table.insert(code, instruction)
    return instruction, #code
  end

  --// CODE GENERATION //--
  local processExpressionNode, processStatementNode, processCodeBlock, processFunction
  function processExpressionNode(node, expressionRegister)
    local expressionRegister = expressionRegister or allocateRegister()
    local nodeType = node.TYPE
    while nodeType == "Expression" do
      node = node.Value
      nodeType = node.TYPE
    end

    if nodeType == "Number" or nodeType == "String" then
      -- OP_LOADK [A, Bx]    R(A) := Kst(Bx)
      addInstruction("LOADK", expressionRegister, findOrCreateConstant(node.Value))
    elseif nodeType == "Function" then
      local codeblock  = node.Codeblock
      local parameters = node.Parameters
      local isVarArg   = node.isVarArg
      processFunction(codeblock, expressionRegister, parameters, isVarArg)
    elseif nodeType == "FunctionCall" then
      processExpressionNode(node.Expression, expressionRegister)
      local argumentRegisters = {}
      for index, argument in ipairs(node.Arguments) do
        local currentArgumentRegisters = { processExpressionNode(argument) }
        for _, register in ipairs(currentArgumentRegisters) do
          table.insert(argumentRegisters, register)
        end
      end
      local returnAmount = node.ReturnValueAmount + 1
      local argumentAmount = #node.Arguments + 1
      if returnAmount <= 0 then returnAmount = 0 end
      if node.Arguments[#node.Arguments] then
        local lastArgument = node.Arguments[#node.Arguments]
        if isMultiretNode(lastArgument) then
          argumentAmount = 0
        end
      end
      -- OP_CALL [A, B, C]    R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1))
      addInstruction("CALL", expressionRegister, argumentAmount, returnAmount)
      deallocateRegisters(argumentRegisters)
      local returnRegisters = { expressionRegister }
      for index = expressionRegister + 1, expressionRegister + node.ReturnValueAmount - 1 do
        local register = allocateRegister()
        table.insert(returnRegisters, index)
      end
      return unpack(returnRegisters)
    elseif nodeType == "MethodCall" then
      local nodeIndexIndex      = node.Expression.Index
      local nodeIndexExpression = node.Expression.Expression
      processExpressionNode(nodeIndexExpression, expressionRegister)
      local selfArgumentRegister = allocateRegister()
      local nodeIndexRegister = processExpressionNode(nodeIndexIndex)
      -- OP_SELF [A, B, C]    R(A+1) := R(B) R(A) := R(B)[RK(C)]
      addInstruction("SELF", expressionRegister, expressionRegister, nodeIndexRegister)
      deallocateRegister(nodeIndexRegister)
      local argumentRegisters = { selfArgumentRegister } -- Allocate the self register
      for index, argument in ipairs(node.Arguments) do
        local currentArgumentRegisters = { processExpressionNode(argument) }
        for _, register in ipairs(currentArgumentRegisters) do
          table.insert(argumentRegisters, register)
        end
      end
      local returnAmount = node.ReturnValueAmount + 1
      local argumentAmount = #node.Arguments + 2
      if returnAmount <= 0 then returnAmount = 0 end
      -- OP_CALL [A, B, C]    R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1))
      addInstruction("CALL", expressionRegister, argumentAmount, returnAmount)
      deallocateRegisters(argumentRegisters)
      local returnRegisters = { expressionRegister }
      for index = expressionRegister + 1, expressionRegister + node.ReturnValueAmount - 1 do
        local register = allocateRegister()
        table.insert(returnRegisters, index)
      end
      return unpack(returnRegisters)
    elseif nodeType == "Constant" then
      local nodeValue = node.Value
      if nodeValue ~= "nil" then
        local secondValue = (nodeValue == "true" and 1) or 0
        -- OP_LOADBOOL [A, B, C]    R(A) := (Bool)B if (C) pc++
        addInstruction("LOADBOOL", expressionRegister, secondValue, 0)
      else
        -- OP_LOADNIL [A, B]    R(A) := ... := R(B) := nil
        addInstruction("LOADNIL", expressionRegister, expressionRegister)
      end
    elseif nodeType == "VarArg" then
      local returnAmount = node.ReturnValueAmount + 1
      if returnAmount <= 0 then returnAmount = 0 end
      -- OP_VARARG [A, B]    R(A), R(A+1), ..., R(A+B-1) = vararg
      addInstruction("VARARG", expressionRegister, returnAmount)
      local returnRegisters = { expressionRegister }
      for index = expressionRegister + 1, expressionRegister + node.ReturnValueAmount - 1 do
        local register = allocateRegister()
        table.insert(returnRegisters, index)
      end
      return unpack(returnRegisters)
    elseif nodeType == "TableIndex" then
      processExpressionNode(node.Expression, expressionRegister)
      local indexRegister = processExpressionNode(node.Index)
      -- OP_GETTABLE [A, B, C]    R(A) := R(B)[RK(C)]
      addInstruction("GETTABLE", expressionRegister, expressionRegister, indexRegister)
      deallocateRegister(indexRegister)
    elseif nodeType == "Table" then
      local elements = node.Elements
      -- OP_NEWTABLE [A, B, C]    R(A) := {} (size = B,C)
      addInstruction("NEWTABLE", expressionRegister, 0, 0)
      for _, element in ipairs(elements) do
        if not element.IsImplicitKey then
          local valueRegister = processExpressionNode(element.Value)
          local keyRegister = processExpressionNode(element.Key)
          deallocateRegisters({ valueRegister, keyRegister })
          -- OP_SETTABLE [A, B, C]    R(A)[RK(B)] := RK(C)
          addInstruction("SETTABLE", expressionRegister, keyRegister, valueRegister)
        end
      end
      local implicitKeyValues = {}
      local lastImplicitElementValue
      for _, element in ipairs(elements) do
        if element.IsImplicitKey then
          lastImplicitElementValue = element.Value
          local valueRegister = processExpressionNode(element.Value)
          table.insert(implicitKeyValues, valueRegister)
        end
      end
      if #implicitKeyValues > 0 then
        local implicitKeyAmount = #implicitKeyValues
        if isMultiretNode(lastImplicitElementValue.Value) then
          implicitKeyAmount = 0
        end
        -- OP_SETLIST [A, B, C]    R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B
        addInstruction("SETLIST", expressionRegister, implicitKeyAmount, 1)
        deallocateRegisters(implicitKeyValues)
      end
    elseif nodeType == "Variable" then
      local variableType = node.VariableType
      if variableType == "Global" then
        -- OP_GETGLOBAL [A, Bx]    R(A) := Gbl[Kst(Bx)]
        addInstruction("GETGLOBAL", expressionRegister, findOrCreateConstant(node.Value))
      elseif variableType == "Local" then
        local variableRegister = findVariableRegister(node.Value)
        -- OP_MOVE [A, B]    R(A) := R(B)
        addInstruction("MOVE", expressionRegister, variableRegister)
      elseif variableType == "Upvalue" then
        -- OP_GETUPVAL [A, B]    R(A) := UpValue[B]
        addInstruction("GETUPVAL", expressionRegister, findOrCreateUpvalue(node.Value))
      end
    elseif nodeType == "BinaryOperator" then
      local nodeOperator = node.Operator
      local opcode = COMPILER_SIMPLE_ARICHMETIC_OPERATOR_LOOKUP[nodeOperator]
                     or COMPILER_COMPARISON_OPERATOR_LOOKUP[nodeOperator]
                     or COMPILER_CONTROL_FLOW_OPERATOR_LOOKUP[nodeOperator]
      if COMPILER_SIMPLE_ARICHMETIC_OPERATOR_LOOKUP[nodeOperator] then
        local leftExpressionRegister = processExpressionNode(node.Left)
        local rightExpressionRegister = processExpressionNode(node.Right)
        addInstruction(opcode, expressionRegister, leftExpressionRegister, rightExpressionRegister)
        deallocateRegisters({ leftExpressionRegister, rightExpressionRegister })
      elseif COMPILER_CONTROL_FLOW_OPERATOR_LOOKUP[nodeOperator] then
        local leftExpressionRegister = processExpressionNode(node.Left, expressionRegister)
        local isConditionTrue = (nodeOperator == "and" and 0) or 1
        -- OP_TEST [A, C]    if not (R(A) <=> C) then pc++
        addInstruction("TEST", leftExpressionRegister, 0, isConditionTrue)
        -- OP_JMP [A, sBx]    pc+=sBx
        local jumpInstruction, jumpInstructionIndex = addInstruction("JMP", 0, 0) -- Placeholder
        processExpressionNode(node.Right, expressionRegister)
        jumpInstruction[3] = #code - jumpInstructionIndex
      elseif COMPILER_COMPARISON_OPERATOR_LOOKUP[nodeOperator] then
        local leftExpressionRegister = processExpressionNode(node.Left)
        local rightExpressionRegister = processExpressionNode(node.Right)
        local instruction, flag = unpack(COMPILER_COMPARISON_INSTRUCTION_LOOKUP[nodeOperator])
        if nodeOperator == ">" or nodeOperator == ">=" then
          leftExpressionRegister, rightExpressionRegister = rightExpressionRegister, leftExpressionRegister
        end
        addInstruction(instruction, flag, leftExpressionRegister, rightExpressionRegister)
        -- OP_JMP [A, sBx]    pc+=sBx
        addInstruction("JMP", 0, 1)
        -- OP_LOADBOOL [A, B, C]    R(A) := (Bool)B if (C) pc++
        addInstruction("LOADBOOL", expressionRegister, 0, 1)
        addInstruction("LOADBOOL", expressionRegister, 1, 0)
        deallocateRegisters({ leftExpressionRegister, rightExpressionRegister })
      elseif nodeOperator == ".." then
        local leftExpressionRegister = processExpressionNode(node.Left)
        local rightExpressionRegister = processExpressionNode(node.Right)
        if (rightExpressionRegister - leftExpressionRegister) ~= 1 then
          error("Concatenation requires consecutive registers")
        end
        -- OP_CONCAT [A, B, C]    R(A) := R(B).. ... ..R(C)
        addInstruction("CONCAT", expressionRegister, leftExpressionRegister, rightExpressionRegister)
        deallocateRegisters({ leftExpressionRegister, rightExpressionRegister })
      end
    elseif nodeType == "UnaryOperator" then
      local nodeOperator = node.Operator
      local operatorOpcode = COMPILER_UNARY_OPERATOR_LOOKUP[nodeOperator]
      local operandExpression = processExpressionNode(node.Operand)
      addInstruction(operatorOpcode, expressionRegister, operandExpression)
      deallocateRegister(operandExpression)
    else
      error("Unsupported expression node type: " .. tostring(nodeType))
    end

    return expressionRegister
  end
  function processStatementNode(node)
    local nodeType = node.TYPE
    if nodeType == "FunctionCall" or nodeType == "MethodCall" then
      local functionRegisters = { processExpressionNode(node) }
      deallocateRegisters(functionRegisters)
    elseif nodeType == "BreakStatement" then
      -- OP_JMP [A, sBx]    pc+=sBx
      local jumpInstruction, jumpInstructionIndex = addInstruction("JMP", 0, 0) -- Placeholder
      table.insert(breakInstructions, jumpInstructionIndex)
    elseif nodeType == "LocalFunctionDeclaration" then
      local name          = node.Name
      local codeblock     = node.Codeblock
      local parameters    = node.Parameters
      local isVarArg      = node.IsVarArg
      local localRegister = allocateRegister()
      registerVariable(name, localRegister)
      processFunction(codeblock, localRegister, parameters, isVarArg)
    elseif nodeType == "FunctionDeclaration" then
      local expression         = node.Expression
      local fields             = node.Fields
      local isMethod           = node.IsMethod
      local codeblock          = node.Codeblock
      local parameters         = node.Parameters
      local isVarArg           = node.IsVarArg
      if #fields > 0 then
        local closureRegister = allocateRegister()
        processFunction(codeblock, closureRegister, parameters, isVarArg)
        local expressionRegister = processExpressionNode(expression)
        for index, field in ipairs(fields) do
          local fieldRegister = allocateRegister()
          -- OP_LOADK [A, Bx]    R(A) := Kst(Bx)
          addInstruction("LOADK", fieldRegister, findOrCreateConstant(field))
          if index == #fields then
            -- OP_SETTABLE [A, B, C]    R(A)[RK(B)] := RK(C)
            addInstruction("SETTABLE", expressionRegister, fieldRegister, closureRegister)
          else
            -- OP_GETTABLE [A, B, C]    R(A) := R(B)[RK(C)]
            addInstruction("GETTABLE", expressionRegister, expressionRegister, fieldRegister)
          end
          deallocateRegister(fieldRegister)
        end
        deallocateRegisters({ expressionRegister, closureRegister })
        return
      end
      if expression.VariableType == "Local" then
        local localRegister = findVariableRegister(expression.Value)
        processFunction(codeblock, localRegister, parameters, isVarArg)
      elseif expression.VariableType == "Upvalue" then
        local upvalueIndex = findOrCreateUpvalue(expression.Value)
        local closureRegister = allocateRegister()
        processFunction(codeblock, closureRegister, parameters, isVarArg)
        -- OP_SETUPVAL [A, B]    UpValue[B] := R(A)
        addInstruction("SETUPVAL", closureRegister, findOrCreateUpvalue(expression.Value))
        deallocateRegister(closureRegister)
      elseif expression.VariableType == "Global" then
        local globalRegister = allocateRegister()
        processFunction(codeblock, globalRegister, parameters, isVarArg)
        -- OP_SETGLOBAL [A, Bx]    Gbl[Kst(Bx)] := R(A)
        addInstruction("SETGLOBAL", globalRegister, findOrCreateConstant(expression.Value))
        deallocateRegister(globalRegister)
      end
    elseif nodeType == "LocalDeclaration" then
      local variableExpressionRegisters = {}
      for index, expression in ipairs(node.Expressions) do
        local expressionRegisters = { processExpressionNode(expression) }
        for index2, expressionRegister in ipairs(expressionRegisters) do
          table.insert(variableExpressionRegisters, expressionRegister)
          if not node.Variables[index + index2 - 1] then
            -- If this expression doesn't have a corresponding variable, deallocate it
            deallocateRegister(expressionRegister)
          end
        end
      end
      for index, localName in ipairs(node.Variables) do
        local expressionRegister = variableExpressionRegisters[index]
        if not expressionRegister then
          expressionRegister = allocateRegister()
          -- Load nil into the register
          -- OP_LOADNIL [A, B]    R(A) := ... := R(B) := nil
          addInstruction("LOADNIL", expressionRegister, expressionRegister)
        end
        registerVariable(localName, expressionRegister)
      end
    elseif nodeType == "NumericForLoop" then
      local variableName = node.VariableName
      local expressions = node.Expressions
      local codeblock = node.Codeblock
      local startRegister = processExpressionNode(expressions[1])
      local endRegister = processExpressionNode(expressions[2])
      local stepRegister = allocateRegister()
      if expressions[3] then
        stepRegister = processExpressionNode(expressions[3], stepRegister)
      else
        -- OP_LOADK [A, Bx]    R(A) := Kst(Bx)
        addInstruction("LOADK", stepRegister, findOrCreateConstant(1))
      end
      -- OP_FORPREP [A, sBx]    R(A)-=R(A+2) pc+=sBx
      local forprepInstruction = addInstruction("FORPREP", startRegister, 0) -- Placeholder
      local loopStart = #code
      registerVariable(variableName, startRegister)
      local oldBreakInstructions = breakInstructions
      breakInstructions = {}
      processCodeBlock(codeblock)
      local loopEnd = #code
      -- OP_FORLOOP [,A sBx]   R(A)+=R(A+2)
      --                       if R(A) <?= R(A+1) then { pc+=sBx R(A+3)=R(A) }
      addInstruction("FORLOOP", startRegister, loopStart - loopEnd - 1)
      forprepInstruction[3] = loopEnd - loopStart
      updateBreakInstructions(breakInstructions)
      breakInstructions = oldBreakInstructions
      unregisterVariable(variableName)
      deallocateRegisters({ startRegister, endRegister, stepRegister })
    elseif nodeType == "GenericForLoop" then
      local iteratorVariables = node.IteratorVariables
      local expressions = node.Expressions
      local codeblock = node.Codeblock
      local iteratorRegisters = {}
      local expressionRegisters = { processExpressionNode(expressions[1]) }
      -- OP_JMP [A, sBx]    pc+=sBx
      local startJmpInstruction = addInstruction("JMP", 0, 0) -- Placeholder
      local forGeneratorRegister = expressionRegisters[1]
      local forStateRegister = expressionRegisters[2]
      local forControlRegister = expressionRegisters[3]
      if not (forGeneratorRegister and forStateRegister and forControlRegister) then
        error("Expected 3 expression registers")
      end
      local loopStart = #code
      for index, iteratorVariable in ipairs(iteratorVariables) do
        local iteratorRegister = allocateRegister()
        iteratorRegisters[index] = iteratorRegister
        registerVariable(iteratorVariable, iteratorRegister)
      end
      local oldBreakInstructions = breakInstructions
      breakInstructions = {}
      processCodeBlock(codeblock)
      -- OP_TFORLOOP [A, C]    R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2))
      --                       if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++
      local tforloopInstruction = addInstruction("TFORLOOP", forGeneratorRegister, 0, #iteratorVariables)
      startJmpInstruction[3] = #code - loopStart - 1
      -- OP_JMP [A, sBx]    pc+=sBx
      addInstruction("JMP", 0, loopStart - #code - 1)
      updateBreakInstructions(breakInstructions)
      breakInstructions = oldBreakInstructions
      deallocateRegisters(expressionRegisters)
      unregisterVariables(iteratorVariables)
    elseif nodeType == "ReturnStatement" then
      local expressionRegisters = {}
      for index, expression in ipairs(node.Expressions) do
        local currentExpressionRegisters = { processExpressionNode(expression) }
        for _, register in ipairs(currentExpressionRegisters) do
          table.insert(expressionRegisters, register)
        end
      end
      local startRegister = expressionRegisters[1] or 0
      local returnAmount = #node.Expressions + 1
      local lastExpression = node.Expressions[#node.Expressions]
      if isMultiretNode(lastExpression) then
        returnAmount = 0
      end
      -- OP_RETURN [A, B]    return R(A), ... ,R(A+B-2)
      addInstruction("RETURN", startRegister, returnAmount, 0)
      deallocateRegisters(expressionRegisters)
    elseif nodeType == "WhileLoop" then
      local loopStart = #code
      local conditionRegister = processExpressionNode(node.Condition)
      -- OP_TEST [A, C]    if not (R(A) <=> C) then pc++
      addInstruction("TEST", conditionRegister, 0, 0)
      -- OP_JMP [A, sBx]    pc+=sBx
      local jumpInstruction = addInstruction("JMP", 0, 0) -- Placeholder
      deallocateRegister(conditionRegister)
      local codeStart = #code
      local oldBreakInstructions = breakInstructions
      breakInstructions = {}
      processCodeBlock(node.Codeblock)
      -- OP_JMP [A, sBx]    pc+=sBx
      local jumpBackInstruction = addInstruction("JMP", 0, loopStart - #code - 1)
      jumpInstruction[3] = #code - codeStart
      updateBreakInstructions(breakInstructions)
      breakInstructions = oldBreakInstructions
    elseif nodeType == "RepeatLoop" then
      local loopStart = #code
      processCodeBlock(node.Codeblock)
      local conditionRegister = processExpressionNode(node.Condition)
      -- OP_TEST [A, C]    if not (R(A) <=> C) then pc++
      addInstruction("TEST", conditionRegister, 0, 0)
      -- OP_JMP [A, sBx]    pc+=sBx
      local jumpInstruction = addInstruction("JMP", 0, loopStart - #code - 1)
      deallocateRegister(conditionRegister)
    elseif nodeType == "DoBlock" then
      processCodeBlock(node.Codeblock)
    elseif nodeType == "IfStatement" then
      local conditionCodeblockStatements = { { Condition = node.Condition, Codeblock = node.Codeblock } }
      for _, elseifNode in ipairs(node.ElseIfs) do
        table.insert(conditionCodeblockStatements, elseifNode)
      end
      local jumpToEndInstructions = {}
      for index, conditionCodeblockStatement in ipairs(conditionCodeblockStatements) do
        local condition = conditionCodeblockStatement.Condition
        local codeBlock = conditionCodeblockStatement.Codeblock
        local conditionRegister = processExpressionNode(condition)
        -- OP_TEST [A, C]    if not (R(A) <=> C) then pc++
        addInstruction("TEST", conditionRegister, 0, 0)
        -- OP_JMP [A, sBx]    pc+=sBx
        local conditionJumpInstruction, conditionJumpInstructionIndex = addInstruction("JMP", 0, 0) -- Placeholder
        deallocateRegister(conditionRegister)
        processCodeBlock(codeBlock)
        if index < #conditionCodeblockStatements or node.ElseCodeblock then
          -- OP_JMP [A, sBx]    pc+=sBx
          table.insert(jumpToEndInstructions, { addInstruction("JMP", 0, 0) })
        end
        conditionJumpInstruction[3] = #code - conditionJumpInstructionIndex
      end
      if node.ElseCodeblock then
        processCodeBlock(node.ElseCodeblock)
      end

      for _, jumpToEndInstruction in ipairs(jumpToEndInstructions) do
        local instructionTable, instructionIndex = jumpToEndInstruction[1], jumpToEndInstruction[2]
        instructionTable[3] = #code - instructionIndex
      end
    elseif nodeType == "VariableAssignment" then
      local expressionRegisters = {}
      for index, expression in ipairs(node.Expressions) do
        local currentExpressionRegisters = { processExpressionNode(expression) }
        for _, register in ipairs(currentExpressionRegisters) do
          table.insert(expressionRegisters, register)
        end
      end
      for index, lvalue in ipairs(node.LValues) do
        local lvalueType = lvalue.TYPE
        if lvalueType == "Variable" then
          local variableType = lvalue.VariableType
          local variableName = lvalue.Value
          local expressionRegister = expressionRegisters[index]
          if not expressionRegister then error("Expected an expression for assignment") end
          if variableType == "Local" then
            local variableRegister = findVariableRegister(variableName)
            -- OP_MOVE [A, B]    R(A) := R(B)
            addInstruction("MOVE", variableRegister, expressionRegister)
          elseif variableType == "Global" then
            -- OP_SETGLOBAL [A, Bx]    Gbl[Kst(Bx)] := R(A)
            addInstruction("SETGLOBAL", expressionRegister, findOrCreateConstant(variableName))
          elseif variableType == "Upvalue" then
            -- OP_SETUPVAL [A, B]    UpValue[B] := R(A)
            addInstruction("SETUPVAL", expressionRegister, findOrCreateUpvalue(variableName))
          end
        elseif lvalueType == "TableIndex" then
          local indexRegister = processExpressionNode(lvalue.Index)
          local tableExpressionRegister = processExpressionNode(lvalue.Expression)
          local expressionRegister = expressionRegisters[index]
          if not expressionRegister then error("Expected an expression for assignment") end
          -- OP_SETTABLE [A, B, C]    R(A)[RK(B)] := RK(C)
          addInstruction("SETTABLE", tableExpressionRegister, indexRegister, expressionRegister)
          deallocateRegisters({ indexRegister, expressionRegister, tableExpressionRegister })
        else
          error("Unsupported lvalue type: " .. lvalueType)
        end
      end
      deallocateRegisters(expressionRegisters)
    else
      error("Unsupported statement node type: " .. tostring(nodeType))
    end
  end
  function processCodeBlock(list, isFunctionScope, parameters)
    enterScope(isFunctionScope)
    if parameters then
      for _, parameter in ipairs(parameters) do
        registerVariable(parameter, allocateRegister())
      end
    end
    for index, node in ipairs(list) do
      processStatementNode(node)
    end
    exitScope()
  end
  function processFunction(codeBlock, expressionRegister, parameters, isVarArg)
    local oldProto  = currentProto
    local proto     = newProto()
    proto.numParams = #parameters
    proto.isVarArg  = isVarArg

    processCodeBlock(codeBlock, true, parameters)

    -- OP_RETURN [A, B]    return R(A), ... ,R(A+B-2)
    addInstruction("RETURN", 0, 1) -- Default return statement
    setProto(oldProto)
    table.insert(protos, proto)
    -- R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))
    addInstruction("CLOSURE", expressionRegister, #protos - 1)

    for index, upvalueName in ipairs(proto.upvalues) do
      local upvalueType = getVariableType(upvalueName)
      if upvalueType == "Local" then
        -- OP_MOVE [A, B]    R(A) := R(B)
        addInstruction("MOVE", 0, findVariableRegister(upvalueName))
      elseif upvalueType == "Upvalue" then
        -- OP_GETUPVAL [A, B]    R(A) := UpValue[B]
        addInstruction("GETUPVAL", 0, findOrCreateUpvalue(upvalueName))
      else error("Unsupported upvalue type: " .. upvalueType) end
    end
    return proto
  end

  --// MAIN //--
  local function generate()
    local proto = newProto()
    processCodeBlock(ast)
    -- OP_RETURN [A, B]    return R(A), ... ,R(A+B-2)
    addInstruction("RETURN", 0, 1) -- Default return statement
    return proto
  end

  return generate()
end

local MODE_iABC = 0
local MODE_iABx = 1
local MODE_iAsBx = 2

local COMPILER_OPCODE_LOOKUP = {
  ["MOVE"]     = {0, MODE_iABC},  ["LOADK"]     = {1, MODE_iABx},  ["LOADBOOL"] = {2, MODE_iABC},  ["LOADNIL"]   = {3, MODE_iABC},
  ["GETUPVAL"] = {4, MODE_iABC},  ["GETGLOBAL"] = {5, MODE_iABx},  ["GETTABLE"] = {6, MODE_iABC},  ["SETGLOBAL"] = {7, MODE_iABx},
  ["SETUPVAL"] = {8, MODE_iABC},  ["SETTABLE"]  = {9, MODE_iABC},  ["NEWTABLE"] = {10, MODE_iABC}, ["SELF"]      = {11, MODE_iABC},
  ["ADD"]      = {12, MODE_iABC}, ["SUB"]       = {13, MODE_iABC}, ["MUL"]      = {14, MODE_iABC}, ["DIV"]       = {15, MODE_iABC},
  ["MOD"]      = {16, MODE_iABC}, ["POW"]       = {17, MODE_iABC}, ["UNM"]      = {18, MODE_iABC}, ["NOT"]       = {19, MODE_iABC},
  ["LEN"]      = {20, MODE_iABC}, ["CONCAT"]    = {21, MODE_iABC}, ["JMP"]      = {22, MODE_iAsBx},["EQ"]        = {23, MODE_iABC},
  ["LT"]       = {24, MODE_iABC}, ["LE"]        = {25, MODE_iABC}, ["TEST"]     = {26, MODE_iABC}, ["TESTSET"]   = {27, MODE_iABC},
  ["CALL"]     = {28, MODE_iABC}, ["TAILCALL"]  = {29, MODE_iABC}, ["RETURN"]   = {30, MODE_iABC}, ["FORLOOP"]   = {31, MODE_iAsBx},
  ["FORPREP"]  = {32, MODE_iAsBx},["TFORLOOP"]  = {33, MODE_iABC}, ["SETLIST"]  = {34, MODE_iABC}, ["CLOSE"]     = {35, MODE_iABC},
  ["CLOSURE"]  = {36, MODE_iABx}, ["VARARG"]    = {37, MODE_iABC}
}

--* Compiler *--
local Compiler = {}
function Compiler.compile(proto)
  --// BYTE MANIPULATION (needed for compiling to bytecode) //--
  local function twosComplement(value)
    local value = value or 0
    if value < 0 then
      value = (-value) - 1
    end
    return value
  end
  local function makeBytes(value, byteCount)
    local bytes = {}
    for i = 1, byteCount do
      bytes[i] = value % 256
      value = math.floor(value / 256)
    end
    return string.char(unpack(bytes))
  end
  local function makeOneByte(value)
    return string.char(value % 256)
  end
  local function makeTwoBytes(value)
    return makeBytes(value, 2)
  end
  local function makeFourBytes(value)
    return makeBytes(value, 4)
  end
  local function makeEightBytes(value)
    return makeBytes(value, 8)
  end
  local function makeDouble(value)
    local sign = (value < 0 and 1) or 0
    local mantissa, exponent = math.frexp(math.abs(value))

    if value == 0 then -- zero
      mantissa, exponent = 0, 0
    elseif value == 1/0 then -- infinity
      mantissa, exponent = 0, 2047
    else
      mantissa = (mantissa * 2 - 1) * math.ldexp(0.5, 53)
      exponent = exponent + 1022
    end

    -- 52-bit mantissa
    local double = {}
    for index = 1, 6 do
      double[index] = mantissa % 256
      mantissa = math.floor(mantissa / 256)
    end

    -- exponent (11 bit)
    double[7] = ((mantissa % 16) + (exponent % 16) * 16) % 256
    double[8] = ((sign * 128) + math.floor(exponent / 16)) % 256
    return string.char(unpack(double))
  end

  --// BYTECODE GENERATION //--
  local makeString, makeConstant, makeInstruction, makeConstantSection,
        makeCodeSection, makeFunction, makeHeader
  function makeString(value)
    local value = value .. "\0"
    local size = makeEightBytes(#value)
    return size .. value
  end
  function makeConstant(constantValue, constantType)
    if constantType == "number" then
      return makeOneByte(3) .. makeDouble(constantValue)
    elseif constantType == "string" then
      return makeOneByte(4) .. makeString(constantValue)
    elseif constantType == "boolean" then
      local secondByte = (constantValue and 1) or 0
      return makeOneByte(1) .. makeOneByte(secondByte)
    elseif constantType == "nil" then
      return makeOneByte(0)
    end
    error("Unsupported constant type: " .. constantType)
  end
  function makeInstruction(instruction)
    local opcodeTable = COMPILER_OPCODE_LOOKUP[instruction[1]]
    local opcode, opmode = unpack(opcodeTable)
    local a = twosComplement(instruction[2])
    local instructionNumber = opcode
    instructionNumber = instructionNumber + (a * 64) -- a << 6
    if opmode == MODE_iABC then
      local b = twosComplement(instruction[3])
      local c = twosComplement(instruction[4])
      instructionNumber = instructionNumber + (b * 8388608) -- b << 23
      instructionNumber = instructionNumber + (c * 16384)   -- c << 14
    elseif opmode == MODE_iABx then
      local b = twosComplement(instruction[3])
      instructionNumber = instructionNumber + (b * 16384) -- b << 14
    elseif opmode == MODE_iAsBx then
      local b = instruction[3]
      instructionNumber = instructionNumber + ((b + 131071) * 16384) -- (b + 131071) << 14
    end
    return makeFourBytes(instructionNumber)
  end
  function makeConstantSection(proto)
    local constantSection = makeFourBytes(#proto.constants) -- Number of constants
    for _, constant in ipairs(proto.constants) do
      local constantType = type(constant)
      constantSection = constantSection .. makeConstant(constant, constantType)
    end
    constantSection = constantSection .. makeFourBytes(#proto.protos) -- Number of protos
    for _, proto in ipairs(proto.protos) do
      constantSection = constantSection .. makeFunction(proto)
    end
    return constantSection
  end
  function makeCodeSection(proto)
    local codeSection = makeFourBytes(#proto.code) -- Number of instructions
    for _, instruction in ipairs(proto.code) do
      codeSection = codeSection .. makeInstruction(instruction)
    end
    return codeSection
  end
  function makeFunction(proto)
    local functionHeader = makeString(proto.functionName) -- Function name
    functionHeader = functionHeader .. makeFourBytes(0) -- Line defined
    functionHeader = functionHeader .. makeFourBytes(0) -- Last line defined
    functionHeader = functionHeader .. makeOneByte(#proto.upvalues) -- nups (Number of upvalues)
    functionHeader = functionHeader .. makeOneByte(proto.numParams) -- Number of parameters
    functionHeader = functionHeader .. makeOneByte((proto.isVarArg and 2) or 0) -- Is vararg
    functionHeader = functionHeader .. makeOneByte(128) -- Max stack size
    functionHeader = functionHeader .. makeCodeSection(proto)
    functionHeader = functionHeader .. makeConstantSection(proto)
    functionHeader = functionHeader .. makeFourBytes(0) -- Line info
    functionHeader = functionHeader .. makeFourBytes(0) -- Local variables
    functionHeader = functionHeader .. makeFourBytes(0) -- Upvalues
    return functionHeader
  end
  function makeHeader()
    local header = "\27Lua" -- Signature
    header = header .. string.char(0x51)  -- Version 5.1
    header = header .. "\0"  -- Format 0 (official)
    header = header .. "\1"  -- Little endian
    header = header .. "\4"  -- sizeof(int)
    header = header .. "\8"  -- sizeof(size_t)
    header = header .. "\4"  -- sizeof(Instruction)
    header = header .. "\8"  -- sizeof(lua_Number)
    header = header .. "\0"  -- Integral flag
    return header
  end

  --// MAIN //--
  local function compile()
    local header = makeHeader()
    local functionHeader = makeFunction(proto)
    return header .. functionHeader
  end

  return compile()
end

return {
  Tokenizer = Tokenizer,
  Parser = Parser,
  InstructionGenerator = InstructionGenerator,
  Compiler = Compiler
}
--[[

TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE
T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E
T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E
T:::::TT:::::::TT:::::THH::::::H     H::::::HHEE::::::EEEEEEEEE::::E
TTTTTT  T:::::T  TTTTTT  H:::::H     H:::::H    E:::::E       EEEEEE
        T:::::T          H:::::H     H:::::H    E:::::E
        T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE
        T:::::T          H:::::::::::::::::H    E:::::::::::::::E
        T:::::T          H:::::::::::::::::H    E:::::::::::::::E
        T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE
        T:::::T          H:::::H     H:::::H    E:::::E
        T:::::T          H:::::H     H:::::H    E:::::E       EEEEEE
      TT:::::::TT      HH::::::H     H::::::HHEE::::::EEEEEEEE:::::E
      T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E
      T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E
      TTTTTTTTTTT      HHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE

TTTTTTTTTTTTTTTTTTTTTTTIIIIIIIIIINNNNNNNN        NNNNNNNNYYYYYYY       YYYYYYY
T:::::::::::::::::::::TI::::::::IN:::::::N       N::::::NY:::::Y       Y:::::Y
T:::::::::::::::::::::TI::::::::IN::::::::N      N::::::NY:::::Y       Y:::::Y
T:::::TT:::::::TT:::::TII::::::IIN:::::::::N     N::::::NY::::::Y     Y::::::Y
TTTTTT  T:::::T  TTTTTT  I::::I  N::::::::::N    N::::::NYYY:::::Y   Y:::::YYY
        T:::::T          I::::I  N:::::::::::N   N::::::N   Y:::::Y Y:::::Y
        T:::::T          I::::I  N:::::::N::::N  N::::::N    Y:::::Y:::::Y
        T:::::T          I::::I  N::::::N N::::N N::::::N     Y:::::::::Y
        T:::::T          I::::I  N::::::N  N::::N:::::::N      Y:::::::Y
        T:::::T          I::::I  N::::::N   N:::::::::::N       Y:::::Y
        T:::::T          I::::I  N::::::N    N::::::::::N       Y:::::Y
        T:::::T          I::::I  N::::::N     N:::::::::N       Y:::::Y
      TT:::::::TT      II::::::IIN::::::N      N::::::::N       Y:::::Y
      T:::::::::T      I::::::::IN::::::N       N:::::::N    YYYY:::::YYYY
      T:::::::::T      I::::::::IN::::::N        N::::::N    Y:::::::::::Y
      TTTTTTTTTTT      IIIIIIIIIINNNNNNNN         NNNNNNN    YYYYYYYYYYYYY

 LLLLLLLLLLL            UUUUUUUU     UUUUUUUU           AAA
 L:::::::::L            U::::::U     U::::::U          A:::A
 L:::::::::L            U::::::U     U::::::U         A:::::A
 LL:::::::LL            UU:::::U     U:::::UU        A:::::::A
   L:::::L               U:::::U     U:::::U        A:::::::::A
   L:::::L               U:::::D     D:::::U       A:::::A:::::A
   L:::::L               U:::::D     D:::::U      A:::::A A:::::A
   L:::::L               U:::::D     D:::::U     A:::::A   A:::::A
   L:::::L               U:::::D     D:::::U    A:::::A     A:::::A
   L:::::L               U:::::D     D:::::U   A:::::AAAAAAAAA:::::A
   L:::::L               U:::::D     D:::::U  A:::::::::::::::::::::A
   L:::::L         LLLLLLU::::::U   U::::::U A:::::AAAAAAAAAAAAA:::::A
 LL:::::::LLLLLLLLL:::::LU:::::::UUU:::::::UA:::::A             A:::::A
 L::::::::::::::::::::::L UU:::::::::::::UUA:::::A               A:::::A
 L::::::::::::::::::::::L   UU:::::::::UU A:::::A                 A:::::A
 LLLLLLLLLLLLLLLLLLLLLLLL     UUUUUUUUU  AAAAAAA                   AAAAAAA

        CCCCCCCCCCCCC     OOOOOOOOO     MMMMMMMM               MMMMMMMMPPPPPPPPPPPPPPPPP   IIIIIIIIIILLLLLLLLLLL             EEEEEEEEEEEEEEEEEEEEEERRRRRRRRRRRRRRRRR
     CCC::::::::::::C   OO:::::::::OO   M:::::::M             M:::::::MP::::::::::::::::P  I::::::::IL:::::::::L             E::::::::::::::::::::ER::::::::::::::::R
   CC:::::::::::::::C OO:::::::::::::OO M::::::::M           M::::::::MP::::::PPPPPP:::::P I::::::::IL:::::::::L             E::::::::::::::::::::ER::::::RRRRRR:::::R
  C:::::CCCCCCCC::::CO:::::::OOO:::::::OM:::::::::M         M:::::::::MPP:::::P     P:::::PII::::::IILL:::::::LL             EE::::::EEEEEEEEE::::ERR:::::R     R:::::R
 C:::::C       CCCCCCO::::::O   O::::::OM::::::::::M       M::::::::::M  P::::P     P:::::P  I::::I    L:::::L                 E:::::E       EEEEEE  R::::R     R:::::R
C:::::C              O:::::O     O:::::OM:::::::::::M     M:::::::::::M  P::::P     P:::::P  I::::I    L:::::L                 E:::::E               R::::R     R:::::R
C:::::C              O:::::O     O:::::OM:::::::M::::M   M::::M:::::::M  P::::PPPPPP:::::P   I::::I    L:::::L                 E::::::EEEEEEEEEE     R::::RRRRRR:::::R
C:::::C              O:::::O     O:::::OM::::::M M::::M M::::M M::::::M  P:::::::::::::PP    I::::I    L:::::L                 E:::::::::::::::E     R:::::::::::::RR
C:::::C              O:::::O     O:::::OM::::::M  M::::M::::M  M::::::M  P::::PPPPPPPPP      I::::I    L:::::L                 E:::::::::::::::E     R::::RRRRRR:::::R
C:::::C              O:::::O     O:::::OM::::::M   M:::::::M   M::::::M  P::::P              I::::I    L:::::L                 E::::::EEEEEEEEEE     R::::R     R:::::R
C:::::C              O:::::O     O:::::OM::::::M    M:::::M    M::::::M  P::::P              I::::I    L:::::L                 E:::::E               R::::R     R:::::R
 C:::::C       CCCCCCO::::::O   O::::::OM::::::M     MMMMM     M::::::M  P::::P              I::::I    L:::::L         LLLLLL  E:::::E       EEEEEE  R::::R     R:::::R
  C:::::CCCCCCCC::::CO:::::::OOO:::::::OM::::::M               M::::::MPP::::::PP          II::::::IILL:::::::LLLLLLLLL:::::LEE::::::EEEEEEEE:::::ERR:::::R     R:::::R
   CC:::::::::::::::C OO:::::::::::::OO M::::::M               M::::::MP::::::::P          I::::::::IL::::::::::::::::::::::LE::::::::::::::::::::ER::::::R     R:::::R
     CCC::::::::::::C   OO:::::::::OO   M::::::M               M::::::MP::::::::P          I::::::::IL::::::::::::::::::::::LE::::::::::::::::::::ER::::::R     R:::::R
        CCCCCCCCCCCCC     OOOOOOOOO     MMMMMMMM               MMMMMMMMPPPPPPPPPP          IIIIIIIIIILLLLLLLLLLLLLLLLLLLLLLLLEEEEEEEEEEEEEEEEEEEEEERRRRRRRR     RRRRRRR

]]

local function createLookupTable(list)
  local lookup = {}
  for _, value in ipairs(list) do
    lookup[value] = true
  end
  return lookup
end
local function makeTrie(table)
  local trieTable = {}
  local longestElement = 0

  for _, op in ipairs(table) do
    if #op > longestElement then
      longestElement = #op
    end

    local node = trieTable
    for index = 1, #op do
      local character = op:sub(index, index)
      node[character] = node[character] or {}
      node = node[character]
    end
    node.Value = op
  end
  return trieTable, longestElement
end

--/// Tokenizer ///--
local TOKENIZER_LUA_CONSTANTS = { "true", "false", "nil" }
local TOKENIZER_LUA_OPERATORS = {
  "^", "*", "/", "%",
  "+", "-", "<", ">",
  "#",

  "<=",  ">=", "==",  "~=",
  "and", "or", "not", ".."
}
local TOKENIZER_RESERVED_KEYWORDS = { "while",    "do",     "end",   "for",
                                      "local",    "repeat", "until", "return",
                                      "in",       "if",     "else",  "elseif",
                                      "function", "then",   "break", "continue" }

local TOKENIZER_LUA_CONSTANTS_LOOKUP     = createLookupTable(TOKENIZER_LUA_CONSTANTS)
local TOKENIZER_LUA_OPERATORS_LOOKUP     = createLookupTable(TOKENIZER_LUA_OPERATORS)
local TOKENIZER_RESERVED_KEYWORDS_LOOKUP = createLookupTable(TOKENIZER_RESERVED_KEYWORDS)

local TOKENIZER_OPERATOR_TRIE, TOKENIZER_OPERATOR_LONGEST = makeTrie(TOKENIZER_LUA_OPERATORS)

--* Tokenizer *--
local Tokenizer = {}
function Tokenizer.tokenize(code)
  local charStream, charStreamLen = {}, 0
  for char in code:gmatch(".") do
    charStreamLen = charStreamLen + 1
    charStream[charStreamLen] = char
  end

  local charStream = charStream
  local curCharPos = 1
  local curChar = charStream[curCharPos]

  --// CHARACTER NAVIGATION //--
  local function lookAhead(n)
    local updatedCharPos = curCharPos + (n or 1)
    local updatedChar    = charStream[updatedCharPos] or "\0"
    return updatedChar
  end
  local function consume(n)
    local updatedCharPos = curCharPos + (n or 1)
    local updatedChar    = charStream[updatedCharPos] or "\0"
    curCharPos = updatedCharPos
    curChar    = updatedChar
    return updatedChar
  end

  --// CHECKERS //--
  local function isWhitespace(char)
    local char = char or curChar
    return char:match("%s")
  end
  local function isNumberStart(char)
    local char = char or curChar
    return char:match("%d")
  end
  local function isNumber(char)
    local char = char or curChar
    return char:match("%d")
  end
  local function isIdentifier(char)
    local char = char or curChar
    return char:match("[%a%d_]")
  end
  local function isIdentifierStart(char)
    local char = char or curChar
    return char:match("[%a_]")
  end
  local function isVarArg()
    return curChar == "." and lookAhead(1) == "." and lookAhead(2) == "."
  end
  local function isString()
    return curChar == '"' or curChar == "'"
  end

  --// CONSUMERS //--
  local function consumeWhitespace()
    local whitespace = { curChar }
    while isWhitespace(lookAhead()) do
      table.insert(whitespace, curChar)
      consume()
    end
    return table.concat(whitespace)
  end
  local function consumeIdentifier()
    local identifier = { curChar }
    while isIdentifier(lookAhead()) do
      table.insert(identifier, consume())
    end
    return table.concat(identifier)
  end
  local function consumeNumber()
    local number = { curChar }
    while isNumber(lookAhead()) do
      table.insert(number, consume())
    end
    return table.concat(number)
  end
  local function consumeString()
    local delimiter = curChar
    local string = { }
    while lookAhead() ~= delimiter do
      table.insert(string, consume())
    end
    consume() -- Consume the closing delimiter
    return table.concat(string)
  end
  local function consumeOperator()
    local node = TOKENIZER_OPERATOR_TRIE
    local operator

    for index = 0, TOKENIZER_OPERATOR_LONGEST - 1 do
      local character = lookAhead(index)
      node = node[character]
      if not node then break end
      if node.Value then operator = node.Value end
    end
    if operator then consume(#operator - 1) end
    return operator
  end

  --// TOKENIZERS //--
  local function getNextToken()
    local curChar = curChar
    if isWhitespace(curChar) then
      consumeWhitespace()
      return
    elseif isNumberStart(curChar) then
      return { TYPE = "Number", Value = tonumber(consumeNumber()) }
    elseif isIdentifierStart(curChar) then
      local identifier = consumeIdentifier()
      if TOKENIZER_LUA_OPERATORS_LOOKUP[identifier] then
        return { TYPE = "Operator", Value = identifier }
      elseif TOKENIZER_RESERVED_KEYWORDS_LOOKUP[identifier] then
        return { TYPE = "Keyword", Value = identifier }
      elseif TOKENIZER_LUA_CONSTANTS_LOOKUP[identifier] then
        return { TYPE = "Constant", Value = identifier }
      else
        return { TYPE = "Identifier", Value = identifier }
      end
    elseif isString(curChar) then
      return { TYPE = "String", Value = consumeString() }
    elseif isVarArg() then
      consume(2)
      return { TYPE = "VarArg" }
    end

    local operator = consumeOperator()
    if operator then
      return { TYPE = "Operator", Value = operator }
    end
    return { TYPE = "Character", Value = curChar }
  end

  --// MAIN //--
  local function tokenize()
    local tokens = {}
    while curChar ~= "\0" do
      local token = getNextToken()
      if token then
        table.insert(tokens, token)
      end
      consume()
    end
    return tokens
  end

  return tokenize()
end

--/// Parser ///--
local PARSER_UNARY_OPERATOR_PRECEDENCE = 8
local PARSER_STOP_KEYWORDS       = createLookupTable({ "end", "else", "elseif", "until" })
local PARSER_OPERATOR_PRECEDENCE = { ["+"]   = {6, 6},  ["-"]  = {6, 6},
                                     ["*"]   = {7, 7},  ["/"]  = {7, 7}, ["%"] = {7, 7},
                                     ["^"]   = {10, 9}, [".."] = {5, 4},
                                     ["=="]  = {3, 3},  ["~="] = {3, 3},
                                     ["<"]   = {3, 3},  [">"]  = {3, 3}, ["<="] = {3, 3}, [">="] = {3, 3},
                                     ["and"] = {2, 2},  ["or"] = {1, 1} }
local PARSER_LUA_UNARY_OPERATORS  = createLookupTable({ "-", "#", "not" })
local PARSER_LUA_BINARY_OPERATORS = createLookupTable({ "+",  "-",   "*",  "/",
                                      "%",  "^",   "..", "==",
                                      "~=", "<",   ">",  "<=",
                                      ">=", "and", "or" })

--* Parser *--
local Parser = {}
function Parser.parse(tokens)
  local tokens            = tokens
  local currentToken      = tokens[1]
  local currentTokenIndex = 1
  local scopeStack        = {}
  local currentScope      = {}

  --// TOKEN NAVIGATION //--
  local function lookAhead(n)
    local updatedTokenIndex = currentTokenIndex + (n or 1)
    local updatedToken      = tokens[updatedTokenIndex]
    return updatedToken
  end
  local function consume(n)
    local updatedTokenIndex = currentTokenIndex + (n or 1)
    local updatedToken      = tokens[updatedTokenIndex]
    currentTokenIndex = updatedTokenIndex
    currentToken      = updatedToken
    return updatedToken
  end

  --// SCOPE MANAGEMENT //--
  local function pushScope()
    local scope = {
      localVariables = {}
    }
    table.insert(scopeStack, scope)
    currentScope = scope
    return scope
  end
  local function popScope()
    scopeStack[#scopeStack] = nil
    currentScope = scopeStack[#scopeStack]
  end

  --// IN-SCOPE VARIABLE MANAGEMENT //--
  local function declareLocalVariable(variable)
    currentScope.localVariables[variable] = true
  end
  local function declareLocalVariables(variables)
    for _, variable in ipairs(variables) do
      declareLocalVariable(variable)
    end
  end
  local function getVariableType(variableName)
    for scopeIndex = #scopeStack, 1, -1 do
      local scope = scopeStack[scopeIndex]
      if scope.localVariables[variableName] then
        return "Local", scopeIndex
      end
    end
    return "Global"
  end

  --// TOKEN CHECKERS //--
  local function checkToken(tokenType, tokenValue, token)
    local token = token or currentToken
    return token
          and token.TYPE  == tokenType
          and token.Value == tokenValue
  end
  local function isComma(token)
    return token and token.TYPE == "Character" and token.Value == ","
  end
  local function isUnaryOperator(token)
    return token and token.TYPE == "Operator" and PARSER_LUA_UNARY_OPERATORS[token.Value]
  end
  local function isBinaryOperator(token)
    return token and token.TYPE == "Operator" and PARSER_LUA_BINARY_OPERATORS[token.Value]
  end

  --// NODE CHECKERS //--
  local function isValidAssignmentLvalue(node)
    local nodeType = node.TYPE
    return nodeType == "Local" or nodeType == "Global" or nodeType == "Index"
  end

  --// EXPECTORS //--
  local function expectCharacter(character, dontConsume)
    assert(currentToken and currentToken.TYPE == "Character", "Expected a character, got: " .. (currentToken or {}).TYPE)
    assert(currentToken.Value == character, "Expected '" .. character .. "'")
    if not dontConsume then consume() end
  end
  local function expectKeyword(keyword, dontConsume)
    assert(currentToken and currentToken.TYPE == "Keyword", "Expected a keyword, got: " .. (currentToken or {}).TYPE)
    assert(currentToken.Value == keyword, "Expected '" .. keyword .. "'")
    if not dontConsume then consume() end
  end

  --// PARSERS //--
  local consumeExpression, consumeExpressions
  local function consumeIdentifierList()
    local identifiers = {}
    while currentToken.TYPE == "Identifier" do
      table.insert(identifiers, currentToken.Value)
      if isComma(lookAhead()) then
        consume() -- Consume the comma
      else break end
    end
    return identifiers
  end
  local function consumeTableIndex(currentExpression)
    consume() -- Consume the "." symbol
    local indexToken = { TYPE = "String", Value = currentToken.Value }
    return { TYPE = "TableIndex", Index = indexToken, Expression = currentExpression }
  end
  local function consumeTable()
    consume() -- Consume the "{" symbol
    local elements = {}
    local internalImplicitKey = 1

    -- Consume table elements
    while not checkToken("Character", "}") do
      local key, value
      local isImplicitKey = false

      -- [<expression>] = <expression>
      if checkToken("Character", "[") then
        consume() -- Consume "["
        key = consumeExpression()
        consume() -- Consume the last token of the key
        expectCharacter("]")
        expectCharacter("=")
        value = consumeExpression()

      -- <identifier> = <expression>
      elseif currentToken.TYPE == "Identifier" and checkToken("Character", "=", lookAhead()) then
        key = { TYPE = "String", Value = currentToken.Value }
        consume() -- Consume key
        consume() -- Consume "="
        value = consumeExpression()

      -- <expression>
      else
        key = { TYPE = "Number", Value = internalImplicitKey }
        internalImplicitKey = internalImplicitKey + 1
        isImplicitKey = true
        value = consumeExpression()
      end
      table.insert(elements, { TYPE = "TableElement", Key = key, Value = value, IsImplicitKey = isImplicitKey })

      consume() -- Consume the last token of the expression
      local shouldContinue = (currentToken.TYPE == "Character") and
                              (currentToken.Value == "," or currentToken.Value == ";")
      if not shouldContinue then break end
      consume() -- Consume "," or ";"
    end

    return { TYPE = "Table", Elements = elements }
  end
  local function consumeBracketTableIndex(currentExpression)
    consume() -- Consume the "[" symbol
    local indexExpression = consumeExpression()
    consume() -- Consume the last token of the index expression
    expectCharacter("]")
    return { TYPE = "TableIndex", Index = indexExpression, Expression = currentExpression }
  end
  local function parseFunctionCall(currentExpression)
    consume() -- Consume the "("
    local arguments = consumeExpressions()
    consume() -- Consume the last token of the expression
    return { TYPE = "FunctionCall", Expression = currentExpression, Arguments = arguments }
  end
  local function consumeOptionalSemilcolon()
    local nextToken = lookAhead()
    if checkToken("Character", ";", nextToken) then
      consume()
    end
  end

  --// EXPRESSSION PARSERS //--
  local parsePrimaryExpression, parseSuffixExpression,
        parsePrefixExpression,  parseUnaryOperator,
        parseBinaryExpression
  function parsePrimaryExpression()
    if not currentToken then return end
    local tokenType = currentToken.TYPE
    local tokenValue = currentToken.Value

    if tokenType == "Number" or tokenType == "String"
     or tokenType == "Constant" or tokenType == "VarArg" then
      return currentToken
    elseif tokenType == "Identifier" then
      local variableType = getVariableType(tokenValue)
      local variableNode = { TYPE = variableType, Value = tokenValue }
      return variableNode
    elseif tokenType == "Character" then
      if tokenValue == "(" then -- Parenthesized expression
        consume() -- Consume the parenthesis
        local expression = consumeExpression()
        consume() -- Consume the last token of the expression
        return expression
      elseif tokenValue == "{" then -- Table constructor
        return consumeTable()
      end
    end
    return nil
  end
  function parseSuffixExpression(primaryExpression)
    local nextToken = lookAhead()
    local nextTokenValue = nextToken and nextToken.Value
    if nextTokenValue == "(" then -- Function call
      consume()
      -- <expression> \( <args> \)
      return parseFunctionCall(primaryExpression)
    elseif nextTokenValue == "." then -- Table access
      consume()
      -- <expression> \. <identifier>
      return consumeTableIndex(primaryExpression)
    elseif nextTokenValue == "[" then -- Table index
      consume()
      -- <expression> \[ <expression> \]
      return consumeBracketTableIndex(primaryExpression)
    end
    return nil
  end
  function parsePrefixExpression(precedence)
    local primaryExpression = parsePrimaryExpression(precedence) -- <primary>
    if not primaryExpression then return end

    -- <suffix>*
    while (true) do
      local newExpression = parseSuffixExpression(primaryExpression)
      if not newExpression then break end
      primaryExpression = newExpression
    end

    return primaryExpression
  end
  function parseUnaryOperator()
    local unaryOperator = currentToken
    -- <unary> ::= <unary operator> <unary> | <primary>
    if not isUnaryOperator(currentToken) then
      return parsePrefixExpression(UNARY_OPERATOR_PRECEDENCE)
    end

    -- <unary operator> <unary>
    consume() -- Consume the operator
    local expression = parseBinaryExpression(UNARY_OPERATOR_PRECEDENCE)
    return { TYPE = "UnaryOperator", Operator = unaryOperator.Value, Operand = expression }
  end
  function parseBinaryExpression(minPrecedence)
    -- <binary> ::= <unary> <binary operator> <binary> | <unary>
    local minPrecedence = minPrecedence or 0
    local expression = parseUnaryOperator() -- <unary>
    if not expression then return end

    -- [<binary operator> <binary>]
    while true do
      local operatorToken = lookAhead()
      local precedence = operatorToken and PARSER_OPERATOR_PRECEDENCE[operatorToken.Value]
      if not isBinaryOperator(operatorToken) or precedence[1] <= minPrecedence then
        break
      end

      -- The <binary operator> <binary> part itself
      local nextToken = consume(2) -- Advance to and consume the operator
      if not nextToken then error("Unexpected end") end

      local right = parseBinaryExpression(precedence[2])
      if not right then error("Unexpected end") end

      expression = { TYPE = "BinaryOperator",
        Operator = operatorToken.Value,
        Left = expression, Right = right }
    end
    return expression
  end
  function consumeExpression()
    local expression = parseBinaryExpression(0)
    if not expression then
      consume(-1)
      return
    end
    return { TYPE = "Expression", Value = expression }
  end
  function consumeExpressions()
    local expressions = { consumeExpression() }
    if #expressions == 0 then return {} end

    local nextToken = lookAhead()
    while isComma(nextToken) do
      consume(2) -- Consume the last token of the last expression and ","
      local expression = consumeExpression()
      table.insert(expressions, expression)
      nextToken = lookAhead()
    end

    return expressions
  end

  --// STATEMENT PARSERS //--
  local getNextNode, parseCodeBlock
  local function parseLocal()
    consume() -- Consume the "local" token
    local variables = consumeIdentifierList()
    declareLocalVariables(variables)
    consume() -- Consume the last token of the last identifier
    expectCharacter("=")
    local expressions = consumeExpressions()
    return { TYPE = "LocalDeclaration", Variables = variables, Expressions = expressions }
  end
  local function parseWhile()
    consume() -- Consume the "while" token
    local condition = consumeExpression()
    consume() -- Consume the last token of the condition
    expectKeyword("do")
    local codeblock = parseCodeBlock()
    expectKeyword("end", true)
    return { TYPE = "WhileLoop", Condition = condition, Codeblock = codeblock }
  end
  local function parseRepeat()
    consume() -- Consume the "repeat" token
    local codeblock = parseCodeBlock()
    expectKeyword("until")
    local condition = consumeExpression()
    return { TYPE = "RepeatLoop", Codeblock = codeblock, Condition = condition }
  end
  local function parseDo()
    consume() -- Consume the "do" token
    local codeblock = parseCodeBlock()
    expectKeyword("end", true)
    return { TYPE = "DoBlock", Codeblock = codeblock }
  end
  local function parseReturn()
    consume() -- Consume the "return" token
    local expressions = consumeExpressions()
    return { TYPE = "ReturnStatement", Expressions = expressions }
  end
  local function parseBreak()
    return { TYPE = "BreakStatement" }
  end
  local function parseIf()
    consume() -- Consume the "if" token
    local condition = consumeExpression()
    consume() -- Consume the last token of the condition
    expectKeyword("then")
    local codeblock = parseCodeBlock()
    local elseifs = {}
    while checkToken("Keyword", "elseif") do
      consume() -- Consume the "elseif" token
      local elseifCondition = consumeExpression()
      consume() -- Consume the last token of the condition
      expectKeyword("then")
      local elseifCodeblock = parseCodeBlock()
      table.insert(elseifs, { Condition = elseifCondition, Codeblock = elseifCodeblock })
    end
    local elseCodeblock
    if checkToken("Keyword", "else") then
      consume() -- Consume the "else" token
      elseCodeblock = parseCodeBlock()
    end
    expectKeyword("end", true)
    return { TYPE = "IfStatement", Condition = condition, Codeblock = codeblock, ElseIfs = elseifs, ElseCodeblock = elseCodeblock }
  end
  local function parseAssignment(lvalue)
    local lvalues = { lvalue }
    consume() -- Consume the last token of the lvalue
    while isComma(currentToken) do
      consume() -- Consume the comma
      local nextLValue = parsePrefixExpression()
      if not nextLValue then error("Expected an lvalue") end
      if not isValidAssignmentLvalue(nextLValue) then
        error("Expected a variable or index, got: " .. nextLValue.TYPE)
      end
      table.insert(lvalues, nextLValue)
      consume() -- Consume the last token of the lvalue
    end
    expectCharacter("=")
    local expressions = consumeExpressions()
    return { TYPE = "VariableAssignment", LValues = lvalues, Expressions = expressions }
  end
  local function parseFunctionCallOrVariableAssignment()
    local lvalue = parsePrefixExpression()
    local lvalueType = lvalue.TYPE
    if lvalue then
      if isValidAssignmentLvalue(lvalue) then
        return parseAssignment(lvalue)
      elseif lvalueType == "FunctionCall" or lvalueType == "MethodCall" then
        return lvalue
      else
        error("Unexpected lvalue type: " .. lvalueType)
      end
    end

    error("Expected an lvalue, got: " .. stringifyTable(currentToken))
  end

  --// CODE BLOCK PARSERS //--
  function getNextNode()
    local currentTokenValue = currentToken.Value
    local currentTokenType = currentToken.TYPE
    if currentTokenType == "Keyword" then
      local node
      if PARSER_STOP_KEYWORDS[currentTokenValue] then return
      elseif currentTokenValue == "local"        then node = parseLocal()
      elseif currentTokenValue == "while"        then node = parseWhile()
      elseif currentTokenValue == "repeat"       then node = parseRepeat()
      elseif currentTokenValue == "do"           then node = parseDo()
      elseif currentTokenValue == "return"       then node = parseReturn()
      elseif currentTokenValue == "break"        then node = parseBreak()
      elseif currentTokenValue == "if"           then node = parseIf()
      else error("Unsupported keyword: " .. currentTokenValue) end
      consumeOptionalSemilcolon()
      return node
    end

    local node = parseFunctionCallOrVariableAssignment()
    consumeOptionalSemilcolon()
    return node
  end
  function parseCodeBlock()
    pushScope()
    local nodeList = { TYPE = "Group" }
    while currentToken do
      local node = getNextNode()
      if not node then break end
      table.insert(nodeList, node)
      consume()
    end
    popScope()
    return nodeList
  end

  --// MAIN //--
  local function parse()
    local ast = parseCodeBlock()
    ast.TYPE = "AST"
    return ast
  end

  return parse()
end

--// Compiler //--
local unpack = (unpack or table.unpack)

local MODE_iABC = 0
local MODE_iABx = 1
local MODE_iAsBx = 2

local COMPILER_OPCODE_TO_NUMBER_LOOKUP = {
  ["MOVE"]     = 0,  ["LOADK"]     = 1,  ["LOADBOOL"] = 2,  ["LOADNIL"]   = 3,
  ["GETUPVAL"] = 4,  ["GETGLOBAL"] = 5,  ["GETTABLE"] = 6,  ["SETGLOBAL"] = 7,
  ["SETUPVAL"] = 8,  ["SETTABLE"]  = 9,  ["NEWTABLE"] = 10, ["SELF"]      = 11,
  ["ADD"]      = 12, ["SUB"]       = 13, ["MUL"]      = 14, ["DIV"]       = 15,
  ["MOD"]      = 16, ["POW"]       = 17, ["UNM"]      = 18, ["NOT"]       = 19,
  ["LEN"]      = 20, ["CONCAT"]    = 21, ["JMP"]      = 22, ["EQ"]        = 23,
  ["LT"]       = 24, ["LE"]        = 25, ["TEST"]     = 26, ["TESTSET"]   = 27,
  ["CALL"]     = 28, ["TAILCALL"]  = 29, ["RETURN"]   = 30, ["FORLOOP"]   = 31,
  ["FORPREP"]  = 32, ["TFORLOOP"]  = 33, ["SETLIST"]  = 34, ["CLOSE"]     = 35,
  ["CLOSURE"]  = 36, ["VARARG"]    = 37
}
local COMPILER_OPMODES = {
  [0] = MODE_iABC,  [1]  = MODE_iABx,  [2]  = MODE_iABC,
  [3] = MODE_iABC,  [4]  = MODE_iABC,  [5]  = MODE_iABx,
  [6] = MODE_iABC,  [7]  = MODE_iABx,  [8]  = MODE_iABC,
  [9] = MODE_iABC,  [10] = MODE_iABC,  [11] = MODE_iABC,
  [12] = MODE_iABC, [13] = MODE_iABC,  [14] = MODE_iABC,
  [15] = MODE_iABC, [16] = MODE_iABC,  [17] = MODE_iABC,
  [18] = MODE_iABC, [19] = MODE_iABC,  [20] = MODE_iABC,
  [21] = MODE_iABC, [22] = MODE_iAsBx, [23] = MODE_iABC,
  [24] = MODE_iABC, [25] = MODE_iABC,  [26] = MODE_iABC,
  [27] = MODE_iABC, [28] = MODE_iABC,  [29] = MODE_iABC,
  [30] = MODE_iABC, [31] = MODE_iAsBx, [32] = MODE_iAsBx,
  [33] = MODE_iABC, [34] = MODE_iABC,  [35] = MODE_iABC,
  [36] = MODE_iABx, [37] = MODE_iABC
}

local COMPILER_SIMPLE_ARICHMETIC_OPERATOR_LOOKUP = {
  ["+"] = "ADD", ["-"] = "SUB", ["*"] = "MUL", ["/"] = "DIV",
  ["%"] = "MOD", ["^"] = "POW"
}
local COMPILER_CONDITIONAL_OPERATOR_LOOKUP = {
  ["=="] = "EQ", ["~="] = "EQ",
  ["<"]  = "LT", [">"]  = "LT",
  ["<="] = "LE", [">="] = "LE"
}
local COMPILER_UNARY_OPERATOR_LOOKUP = {
  ["-"] = "UNM", ["#"] = "LEN", ["not"] = "NOT"
}

local COMPILER_CONTROL_FLOW_OPERATOR_LOOKUP = createLookupTable({"and", "or"})
local NEGATIVE_CONDITIONAL_OPERATOR_LOOKUP = createLookupTable({"~=", ">", ">="})

--* Compiler *--
local Compiler = {}
function Compiler.compile(ast)
  local locals = {}
  local takenRegisters = {}
  local code = {}
  local constants = {}
  local constantLookup = {}

  --// REGISTER MANAGEMENT //--
  local function allocateRegister()
    for i = 0, 255 do
      if not takenRegisters[i] then
        takenRegisters[i] = true
        return i
      end
    end
    error("Out of registers")
  end
  local function deallocateRegister(register)
    takenRegisters[register] = nil
  end
  local function deallocateRegisters(registers)
    for _, register in ipairs(registers) do
      takenRegisters[register] = nil
    end
  end

  --// UTILITY FUNCTIONS //--
  local function findOrCreateConstant(value)
    if constantLookup[value] then
      return constantLookup[value]
    end
    table.insert(constants, value)
    local constantIndex = -(#constants)
    constantLookup[value] = constantIndex
    return constantIndex
  end
  local function addInstruction(opname, a, b, c)
    local instruction = { opname, a, b, c }
    table.insert(code, instruction)
    return instruction, #code
  end
  local function registerVariable(localName, register)
    locals[localName] = register
  end

  --// CODE GENERATION //--
  local processExpressionNode, processStatementNode, processCodeBlock, processAST
  function processExpressionNode(node, expressionRegister)
    local expressionRegister = expressionRegister or allocateRegister()
    local nodeType = node.TYPE
    while nodeType == "Expression" do
      node = node.Value
      nodeType = node.TYPE
    end

    if nodeType == "Number" or nodeType == "String" then
      addInstruction("LOADK", expressionRegister, findOrCreateConstant(node.Value))
    elseif nodeType == "Constant" then
      local nodeValue = node.Value
      if nodeValue ~= "nil" then
        addInstruction("LOADBOOL", expressionRegister, nodeValue == "true" and 1 or 0, 0)
      else
        addInstruction("LOADNIL", expressionRegister, expressionRegister)
      end
    elseif nodeType == "TableIndex" then
      local indexRegister = processExpressionNode(node.Index)
      processExpressionNode(node.Expression, expressionRegister)
      addInstruction("GETTABLE", expressionRegister, expressionRegister, indexRegister)
      deallocateRegister(indexRegister)
    elseif nodeType == "Table" then
      local elements = node.Elements
      addInstruction("NEWTABLE", expressionRegister, 0, 0)
      local temporaryRegisters = {}
      local numberOfImplicitKeys = 0
      for _, element in ipairs(elements) do
        if element.ImplicitKey then
          table.insert(temporaryRegisters, processExpressionNode(element.Value))
          numberOfImplicitKeys = numberOfImplicitKeys + 1
        end
      end
      addInstruction("SETLIST", expressionRegister, numberOfImplicitKeys, 1)
      deallocateRegisters(temporaryRegisters)
      for _, element in ipairs(elements) do
        if not element.ImplicitKey then
          local valueRegister = processExpressionNode(element.Value)
          local keyRegister = processExpressionNode(element.Key)
          deallocateRegisters({ valueRegister, keyRegister })
          addInstruction("SETTABLE", expressionRegister, keyRegister, valueRegister)
        end
      end
    elseif nodeType == "Global" then
      addInstruction("GETGLOBAL", expressionRegister, findOrCreateConstant(node.Value))
    elseif nodeType == "Local" then
      addInstruction("MOVE", expressionRegister, locals[node.Value])
    elseif nodeType == "BinaryOperator" then
      local nodeOperator = node.Operator
      local opcode = COMPILER_SIMPLE_ARICHMETIC_OPERATOR_LOOKUP[nodeOperator]
                     or COMPILER_CONDITIONAL_OPERATOR_LOOKUP[nodeOperator]
                     or COMPILER_CONTROL_FLOW_OPERATOR_LOOKUP[nodeOperator]
      if not opcode then error("Unsupported binary operator: " .. tostring(nodeOperator)) end
      if COMPILER_SIMPLE_ARICHMETIC_OPERATOR_LOOKUP[nodeOperator] then
        local leftExpressionRegister = processExpressionNode(node.Left)
        local rightExpressionRegister = processExpressionNode(node.Right)
        addInstruction(opcode, expressionRegister, leftExpressionRegister, rightExpressionRegister)
        deallocateRegisters({ leftExpressionRegister, rightExpressionRegister })
      elseif COMPILER_CONTROL_FLOW_OPERATOR_LOOKUP[nodeOperator] then
        local leftExpressionRegister = processExpressionNode(node.Left, expressionRegister)
        local isConditionTrue = (nodeOperator == "and" and 0) or 1
        addInstruction("TEST", leftExpressionRegister, 0, isConditionTrue)
        local jumpInstruction, jumpInstructionIndex = addInstruction("JMP", 0, 0) -- Placeholder
        processExpressionNode(node.Right, expressionRegister)
        jumpInstruction[3] = #code - jumpInstructionIndex
      else
        local leftExpressionRegister = processExpressionNode(node.Left)
        local rightExpressionRegister = processExpressionNode(node.Right)
        local isConditionTrue = (NEGATIVE_CONDITIONAL_OPERATOR_LOOKUP[nodeOperator] and 0) or 1
        addInstruction(opcode, isConditionTrue, leftExpressionRegister, rightExpressionRegister)
        addInstruction("JMP", 0, 1)
        addInstruction("LOADBOOL", expressionRegister, 0, 1)
        addInstruction("LOADBOOL", expressionRegister, 1, 0)
        deallocateRegisters({ leftExpressionRegister, rightExpressionRegister })
      end
    elseif nodeType == "UnaryOperator" then
      local nodeOperator = node.Operator
      local operatorOpcode = COMPILER_UNARY_OPERATOR_LOOKUP[nodeOperator]
      if not operatorOpcode then
        error("Unsupported unary operator: " .. tostring(nodeOperator))
      end
      local operandExpression = processExpressionNode(node.Operand)
      addInstruction(operatorOpcode, expressionRegister, operandExpression)
      deallocateRegister(operandExpression)
    else
      error("Unsupported expression node type: " .. tostring(nodeType))
    end

    return expressionRegister
  end
  function processStatementNode(node)
    local nodeType = node.TYPE
    if nodeType == "FunctionCall" then
      local expressionRegister = processExpressionNode(node.Expression)
      local argumentRegisters = {}
      for index, argument in ipairs(node.Arguments) do
        argumentRegisters[index] = processExpressionNode(argument)
      end
      addInstruction("CALL", expressionRegister, #node.Arguments + 1, 1)
      deallocateRegister(expressionRegister)
      deallocateRegisters(argumentRegisters)
    elseif nodeType == "LocalDeclaration" then
      local expressionRegisters = {}
      for index, expression in ipairs(node.Expressions) do
        local expressionRegister = processExpressionNode(expression)
        table.insert(expressionRegisters, expressionRegister)
        if not node.Variables[index] then
          -- If this expression doesn't have a corresponding variable, deallocate it
          deallocateRegister(expressionRegister)
        end
      end
      for index, localName in ipairs(node.Variables) do
        local expressionRegister = expressionRegisters[index]
        if not expressionRegister then
          -- Load nil into the register
          expressionRegister = allocateRegister()
          addInstruction("LOADNIL", expressionRegister, expressionRegister)
        end
        registerVariable(localName, expressionRegister)
      end
    elseif nodeType == "ReturnStatement" then
      local expressionRegisters = {}
      for index, expression in ipairs(node.Expressions) do
        local expressionRegister = processExpressionNode(expression)
        table.insert(expressionRegisters, expressionRegister)
      end
      local startRegister = expressionRegisters[1] or 0
      addInstruction("RETURN", startRegister, #node.Expressions + 1, 0)
      deallocateRegisters(expressionRegisters)
    elseif nodeType == "WhileLoop" then
      local loopStart = #code
      local conditionRegister = processExpressionNode(node.Condition)
      addInstruction("TEST", conditionRegister, 0, 0)
      local jumpInstruction = addInstruction("JMP", 0, 0) -- Placeholder
      deallocateRegister(conditionRegister)
      local codeStart = #code
      processCodeBlock(node.Codeblock)
      local jumpBackInstruction = addInstruction("JMP", 0, loopStart - #code)
      jumpInstruction[3] = #code - codeStart
    elseif nodeType == "RepeatLoop" then
      local loopStart = #code
      processCodeBlock(node.Codeblock)
      local conditionRegister = processExpressionNode(node.Condition)
      addInstruction("TEST", conditionRegister, 0, 0)
      local jumpInstruction = addInstruction("JMP", 0, loopStart - #code - 1)
      deallocateRegister(conditionRegister)
    elseif nodeType == "DoBlock" then
      processCodeBlock(node.Codeblock)
    elseif nodeType == "IfStatement" then
      local conditionCodeblockStatements = { { Condition = node.Condition, Codeblock = node.Codeblock } }
      for _, elseifNode in ipairs(node.ElseIfs) do
        table.insert(conditionCodeblockStatements, elseifNode)
      end

      local jumpToEndInstructions = {}
      for index, conditionCodeblockStatement in ipairs(conditionCodeblockStatements) do
        local condition = conditionCodeblockStatement.Condition
        local codeBlock = conditionCodeblockStatement.Codeblock

        local conditionRegister = processExpressionNode(condition)
        addInstruction("TEST", conditionRegister, 0, 0)
        local conditionJumpInstruction, conditionJumpInstructionIndex = addInstruction("JMP", 0, 0) -- Placeholder
        deallocateRegister(conditionRegister)
        processCodeBlock(codeBlock)
        if index < #conditionCodeblockStatements or node.ElseCodeblock then
          table.insert(jumpToEndInstructions, { addInstruction("JMP", 0, 0) })
        end
        conditionJumpInstruction[3] = #code - conditionJumpInstructionIndex
      end
      if node.ElseCodeblock then
        processCodeBlock(node.ElseCodeblock)
      end

      for _, jumpToEndInstruction in ipairs(jumpToEndInstructions) do
        local instructionTable, instructionIndex = jumpToEndInstruction[1], jumpToEndInstruction[2]
        instructionTable[3] = #code - instructionIndex
      end
    elseif nodeType == "VariableAssignment" then
      local expressionRegisters = {}
      for index, expression in ipairs(node.Expressions) do
        local expressionRegister = processExpressionNode(expression)
        table.insert(expressionRegisters, expressionRegister)
      end
      for index, lvalue in ipairs(node.LValues) do
        local lvalueType = lvalue.TYPE
        if lvalueType == "Local" or lvalueType == "Global" then
          local variableName = lvalue.Value
          local expressionRegister = expressionRegisters[index]
          if not expressionRegister then
            error("Expected an expression for assignment")
          end
          if lvalueType == "Local" then
            addInstruction("MOVE", locals[variableName], expressionRegister)
          else
            addInstruction("SETGLOBAL", expressionRegister, findOrCreateConstant(variableName))
          end
        else
          error("Unsupported lvalue type: " .. lvalueType)
        end
      end
      deallocateRegisters(expressionRegisters)
    else
      error("Unsupported statement node type: " .. tostring(nodeType))
    end
  end
  function processCodeBlock(list)
    for index, node in ipairs(list) do
      processStatementNode(node)
    end
  end
  function processAST(ast)
    processCodeBlock(ast)
    addInstruction("RETURN", 0, 1, 0)
  end

  --// Bitwise operations (needed for compiling to bytecode) //--
  local function twosComplement(value)
    local value = value or 0
    if value < 0 then
      value = (-value) - 1
    end
    return value
  end
  local function makeOneByte(value)
    return string.char(value % 256)
  end
  local function makeTwoBytes(value)
    local bytes = {}
    for i = 1, 2 do
      bytes[i] = value % 256
      value = math.floor(value / 256)
    end
    return string.char(unpack(bytes))
  end
  local function makeFourBytes(value)
    local bytes = {}
    for i = 1, 4 do
      bytes[i] = value % 256
      value = math.floor(value / 256)
    end
    return string.char(unpack(bytes))
  end
  local function makeEightBytes(value)
    local bytes = {}
    for i = 1, 8 do
      bytes[i] = value % 256
      value = math.floor(value / 256)
    end
    return string.char(unpack(bytes))
  end
  local function makeDouble(value)
    local sign = (value < 0 and 1) or 0
    local value = math.abs(value)
    local mantissa, exponent = math.frexp(value)

    if value == 0 then -- zero
      mantissa, exponent = 0, 0
    elseif value == 1/0 then -- infinity
      mantissa, exponent = 0, 2047
    else
      mantissa = (mantissa * 2 - 1) * math.ldexp(0.5, 53)
      exponent = exponent + 1022
    end

    -- 52-bit mantissa
    local double = {}
    for index = 1, 6 do
      double[index] = mantissa % 256
      mantissa = math.floor(mantissa / 256)
    end

    -- exponent (11 bit)
    double[7] = ((mantissa % 16) + (exponent % 16) * 16) % 256
    double[8] = ((sign * 128) + math.floor(exponent / 16)) % 256
    return string.char(unpack(double))
  end
  local function makeString(value)
    local value = value .. "\0"
    local size = makeEightBytes(#value)
    return size .. value
  end
  local function makeConstant(constantValue, constantType)
    if constantType == "number" then
      return makeOneByte(3) .. makeDouble(constantValue)
    elseif constantType == "string" then
      return makeOneByte(4) .. makeString(constantValue)
    elseif constantType == "boolean" then
      local secondByte = (constantValue and 1) or 0
      return makeOneByte(1) .. makeOneByte(secondByte)
    elseif constantType == "nil" then
      return makeOneByte(0)
    else
      error("Unsupported constant type: " .. constantType)
    end
  end
  local function makeInstruction(instruction)
    local opcode = COMPILER_OPCODE_TO_NUMBER_LOOKUP[instruction[1]]
    local opmode = COMPILER_OPMODES[opcode]
    local mode = opmode
    local instructionNumber = 0
    if opmode == MODE_iABC then
      local a = twosComplement(instruction[2])
      local b = twosComplement(instruction[3])
      local c = twosComplement(instruction[4])
      instructionNumber = instructionNumber + opcode
      instructionNumber = instructionNumber + (a * 64) -- a << 6
      instructionNumber = instructionNumber + (b * 8388608) -- b << 23
      instructionNumber = instructionNumber + (c * 16384) -- c << 14
    elseif opmode == MODE_iABx then
      local a = twosComplement(instruction[2])
      local b = twosComplement(instruction[3])
      instructionNumber = instructionNumber + opcode
      instructionNumber = instructionNumber + (a * 64) -- a << 6
      instructionNumber = instructionNumber + (b * 16384) -- b << 14
    elseif opmode == MODE_iAsBx then
      local a = twosComplement(instruction[2])
      local b = instruction[3]
      instructionNumber = instructionNumber + opcode
      instructionNumber = instructionNumber + (a * 64) -- a << 6
      instructionNumber = instructionNumber + ((b + 131071) * 16384) -- (b + 131071) << 14
    end
    return makeFourBytes(instructionNumber)
  end
  local function makeConstantSection()
    local constantSection = makeFourBytes(#constants) -- Number of constants
    for _, constant in ipairs(constants) do
      local constantType = type(constant)
      constantSection = constantSection .. makeConstant(constant, constantType)
    end
    constantSection = constantSection .. makeFourBytes(0) -- Number of functions
    return constantSection
  end
  local function makeCodeSection()
    local codeSection = makeFourBytes(#code) -- Number of instructions
    for _, instruction in ipairs(code) do
      codeSection = codeSection .. makeInstruction(instruction)
    end
    return codeSection
  end

  local function makeFunction()
    local functionHeader = makeString("@test.lua") -- Function name
    functionHeader = functionHeader .. makeFourBytes(0) -- Line defined
    functionHeader = functionHeader .. makeFourBytes(0) -- Last line defined
    functionHeader = functionHeader .. makeOneByte(0) -- nups (Number of upvalues)
    functionHeader = functionHeader .. makeOneByte(0) -- Number of parameters
    functionHeader = functionHeader .. makeOneByte(2) -- Is vararg (2 = VARARG_HASARG)
    functionHeader = functionHeader .. makeOneByte(128) -- Max stack size

    functionHeader = functionHeader .. makeCodeSection()
    functionHeader = functionHeader .. makeConstantSection()

    functionHeader = functionHeader .. makeFourBytes(0) -- Line info
    functionHeader = functionHeader .. makeFourBytes(0) -- Local variables
    functionHeader = functionHeader .. makeFourBytes(0) -- Upvalues
    return functionHeader
  end
  local function makeHeader()
    local header = "\27Lua" -- Signature
    header = header .. string.char(0x51)  -- Version 5.1
    header = header .. "\0"  -- Format 0 (official)
    header = header .. "\1"  -- Little endian
    header = header .. "\4"  -- sizeof(int)
    header = header .. "\8"  -- sizeof(size_t)
    header = header .. "\4"  -- sizeof(Instruction)
    header = header .. "\8"  -- sizeof(lua_Number)
    header = header .. "\0"  -- Integral flag
    return header
  end

  local function makeBytecode()
    local header = makeHeader()
    local functionHeader = makeFunction()
    return header .. functionHeader
  end

  --// MAIN //--
  local function compile()
    processAST(ast)
    return makeBytecode()
  end

  return compile()
end

return {
  Tokenizer = Tokenizer,
  Parser = Parser,
  Compiler = Compiler
}
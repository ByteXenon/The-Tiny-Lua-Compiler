--[[

TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE
T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E
T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E
T:::::TT:::::::TT:::::THH::::::H     H::::::HHEE::::::EEEEEEEEE::::E
TTTTTT  T:::::T  TTTTTT  H:::::H     H:::::H    E:::::E       EEEEEE
        T:::::T          H:::::H     H:::::H    E:::::E
        T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE
        T:::::T          H:::::::::::::::::H    E:::::::::::::::E
        T:::::T          H:::::::::::::::::H    E:::::::::::::::E
        T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE
        T:::::T          H:::::H     H:::::H    E:::::E
        T:::::T          H:::::H     H:::::H    E:::::E       EEEEEE
      TT:::::::TT      HH::::::H     H::::::HHEE::::::EEEEEEEE:::::E
      T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E
      T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E
      TTTTTTTTTTT      HHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE

TTTTTTTTTTTTTTTTTTTTTTTIIIIIIIIIINNNNNNNN        NNNNNNNNYYYYYYY       YYYYYYY
T:::::::::::::::::::::TI::::::::IN:::::::N       N::::::NY:::::Y       Y:::::Y
T:::::::::::::::::::::TI::::::::IN::::::::N      N::::::NY:::::Y       Y:::::Y
T:::::TT:::::::TT:::::TII::::::IIN:::::::::N     N::::::NY::::::Y     Y::::::Y
TTTTTT  T:::::T  TTTTTT  I::::I  N::::::::::N    N::::::NYYY:::::Y   Y:::::YYY
        T:::::T          I::::I  N:::::::::::N   N::::::N   Y:::::Y Y:::::Y
        T:::::T          I::::I  N:::::::N::::N  N::::::N    Y:::::Y:::::Y
        T:::::T          I::::I  N::::::N N::::N N::::::N     Y:::::::::Y
        T:::::T          I::::I  N::::::N  N::::N:::::::N      Y:::::::Y
        T:::::T          I::::I  N::::::N   N:::::::::::N       Y:::::Y
        T:::::T          I::::I  N::::::N    N::::::::::N       Y:::::Y
        T:::::T          I::::I  N::::::N     N:::::::::N       Y:::::Y
      TT:::::::TT      II::::::IIN::::::N      N::::::::N       Y:::::Y
      T:::::::::T      I::::::::IN::::::N       N:::::::N    YYYY:::::YYYY
      T:::::::::T      I::::::::IN::::::N        N::::::N    Y:::::::::::Y
      TTTTTTTTTTT      IIIIIIIIIINNNNNNNN         NNNNNNN    YYYYYYYYYYYYY

 LLLLLLLLLLL            UUUUUUUU     UUUUUUUU           AAA
 L:::::::::L            U::::::U     U::::::U          A:::A
 L:::::::::L            U::::::U     U::::::U         A:::::A
 LL:::::::LL            UU:::::U     U:::::UU        A:::::::A
   L:::::L               U:::::U     U:::::U        A:::::::::A
   L:::::L               U:::::D     D:::::U       A:::::A:::::A
   L:::::L               U:::::D     D:::::U      A:::::A A:::::A
   L:::::L               U:::::D     D:::::U     A:::::A   A:::::A
   L:::::L               U:::::D     D:::::U    A:::::A     A:::::A
   L:::::L               U:::::D     D:::::U   A:::::AAAAAAAAA:::::A
   L:::::L               U:::::D     D:::::U  A:::::::::::::::::::::A
   L:::::L         LLLLLLU::::::U   U::::::U A:::::AAAAAAAAAAAAA:::::A
 LL:::::::LLLLLLLLL:::::LU:::::::UUU:::::::UA:::::A             A:::::A
 L::::::::::::::::::::::L UU:::::::::::::UUA:::::A               A:::::A
 L::::::::::::::::::::::L   UU:::::::::UU A:::::A                 A:::::A
 LLLLLLLLLLLLLLLLLLLLLLLL     UUUUUUUUU  AAAAAAA                   AAAAAAA

        CCCCCCCCCCCCC     OOOOOOOOO     MMMMMMMM               MMMMMMMMPPPPPPPPPPPPPPPPP   IIIIIIIIIILLLLLLLLLLL             EEEEEEEEEEEEEEEEEEEEEERRRRRRRRRRRRRRRRR
     CCC::::::::::::C   OO:::::::::OO   M:::::::M             M:::::::MP::::::::::::::::P  I::::::::IL:::::::::L             E::::::::::::::::::::ER::::::::::::::::R
   CC:::::::::::::::C OO:::::::::::::OO M::::::::M           M::::::::MP::::::PPPPPP:::::P I::::::::IL:::::::::L             E::::::::::::::::::::ER::::::RRRRRR:::::R
  C:::::CCCCCCCC::::CO:::::::OOO:::::::OM:::::::::M         M:::::::::MPP:::::P     P:::::PII::::::IILL:::::::LL             EE::::::EEEEEEEEE::::ERR:::::R     R:::::R
 C:::::C       CCCCCCO::::::O   O::::::OM::::::::::M       M::::::::::M  P::::P     P:::::P  I::::I    L:::::L                 E:::::E       EEEEEE  R::::R     R:::::R
C:::::C              O:::::O     O:::::OM:::::::::::M     M:::::::::::M  P::::P     P:::::P  I::::I    L:::::L                 E:::::E               R::::R     R:::::R
C:::::C              O:::::O     O:::::OM:::::::M::::M   M::::M:::::::M  P::::PPPPPP:::::P   I::::I    L:::::L                 E::::::EEEEEEEEEE     R::::RRRRRR:::::R
C:::::C              O:::::O     O:::::OM::::::M M::::M M::::M M::::::M  P:::::::::::::PP    I::::I    L:::::L                 E:::::::::::::::E     R:::::::::::::RR
C:::::C              O:::::O     O:::::OM::::::M  M::::M::::M  M::::::M  P::::PPPPPPPPP      I::::I    L:::::L                 E:::::::::::::::E     R::::RRRRRR:::::R
C:::::C              O:::::O     O:::::OM::::::M   M:::::::M   M::::::M  P::::P              I::::I    L:::::L                 E::::::EEEEEEEEEE     R::::R     R:::::R
C:::::C              O:::::O     O:::::OM::::::M    M:::::M    M::::::M  P::::P              I::::I    L:::::L                 E:::::E               R::::R     R:::::R
 C:::::C       CCCCCCO::::::O   O::::::OM::::::M     MMMMM     M::::::M  P::::P              I::::I    L:::::L         LLLLLL  E:::::E       EEEEEE  R::::R     R:::::R
  C:::::CCCCCCCC::::CO:::::::OOO:::::::OM::::::M               M::::::MPP::::::PP          II::::::IILL:::::::LLLLLLLLL:::::LEE::::::EEEEEEEE:::::ERR:::::R     R:::::R
   CC:::::::::::::::C OO:::::::::::::OO M::::::M               M::::::MP::::::::P          I::::::::IL::::::::::::::::::::::LE::::::::::::::::::::ER::::::R     R:::::R
     CCC::::::::::::C   OO:::::::::OO   M::::::M               M::::::MP::::::::P          I::::::::IL::::::::::::::::::::::LE::::::::::::::::::::ER::::::R     R:::::R
        CCCCCCCCCCCCC     OOOOOOOOO     MMMMMMMM               MMMMMMMMPPPPPPPPPP          IIIIIIIIIILLLLLLLLLLLLLLLLLLLLLLLLEEEEEEEEEEEEEEEEEEEEEERRRRRRRR     RRRRRRR

]]

local function createLookupTable(list)
  local lookup = {}
  for _, value in ipairs(list) do
    lookup[value] = true
  end
  return lookup
end

--/// Tokenizer ///--
local TOKENIZER_LUA_CONSTANTS     = { "true", "false", "nil" }
local TOKENIZER_LUA_OPERATORS     = { "+", "-", "*", "/", "%", "^" }
local TOKENIZER_RESERVED_KEYWORDS = { "while",    "do",     "end",   "for",
                                      "local",    "repeat", "until", "return",
                                      "in",       "if",     "else",  "elseif",
                                      "function", "then",   "break", "continue" }

local TOKENIZER_LUA_CONSTANTS_LOOKUP     = createLookupTable(TOKENIZER_LUA_CONSTANTS)
local TOKENIZER_LUA_OPERATORS_LOOKUP     = createLookupTable(TOKENIZER_LUA_OPERATORS)
local TOKENIZER_RESERVED_KEYWORDS_LOOKUP = createLookupTable(TOKENIZER_RESERVED_KEYWORDS)

--* Tokenizer *--
local Tokenizer = {}
function Tokenizer.tokenize(code)
  local charStream, charStreamLen = {}, 0
  for char in code:gmatch(".") do
    charStreamLen = charStreamLen + 1
    charStream[charStreamLen] = char
  end

  local charStream = charStream
  local curCharPos = 1
  local curChar = charStream[curCharPos]

  --// CHARACTER NAVIGATION //--
  local function lookAhead(n)
    local updatedCharPos = curCharPos + (n or 1)
    local updatedChar    = charStream[updatedCharPos] or "\0"
    return updatedChar
  end
  local function consume(n)
    local updatedCharPos = curCharPos + (n or 1)
    local updatedChar    = charStream[updatedCharPos] or "\0"
    curCharPos = updatedCharPos
    curChar    = updatedChar
    return updatedChar
  end

  --// CHECKERS //--
  local function isWhitespace(char)
    local char = char or curChar
    return char:match("%s")
  end
  local function isNumberStart(char)
    local char = char or curChar
    return char:match("%d")
  end
  local function isNumber(char)
    local char = char or curChar
    return char:match("%d")
  end
  local function isIdentifier(char)
    local char = char or curChar
    return char:match("[%a%d_]")
  end
  local function isIdentifierStart(char)
    local char = char or curChar
    return char:match("[%a_]")
  end
  local function isVarArg()
    return curChar == "." and lookAhead(1) == "." and lookAhead(2) == "."
  end
  local function isString()
    return curChar == '"' or curChar == "'"
  end

  --// CONSUMERS //--
  local function consumeWhitespace()
    local whitespace = { curChar }
    while isWhitespace(lookAhead()) do
      table.insert(whitespace, curChar)
      consume()
    end
    return table.concat(whitespace)
  end
  local function consumeIdentifier()
    local identifier = { curChar }
    while isIdentifier(lookAhead()) do
      table.insert(identifier, consume())
    end
    return table.concat(identifier)
  end
  local function consumeNumber()
    local number = { curChar }
    while isNumber(lookAhead()) do
      table.insert(number, consume())
    end
    return table.concat(number)
  end
  local function consumeString()
    local delimiter = curChar
    local string = { }
    while lookAhead() ~= delimiter do
      table.insert(string, consume())
    end
    consume() -- Consume the closing delimiter
    return table.concat(string)
  end

  --// TOKENIZERS //--
  local function getNextToken()
    local curChar = curChar
    if isWhitespace(curChar) then
      consumeWhitespace()
      return
    elseif isNumberStart(curChar) then
      return { TYPE = "Number", Value = consumeNumber() }
    elseif isIdentifierStart(curChar) then
      local identifier = consumeIdentifier()
      if TOKENIZER_RESERVED_KEYWORDS_LOOKUP[identifier] then
        return { TYPE = "Keyword", Value = identifier }
      elseif TOKENIZER_LUA_CONSTANTS_LOOKUP[identifier] then
        return { TYPE = "Constant", Value = identifier }
      else
        return { TYPE = "Identifier", Value = identifier }
      end
    elseif isString(curChar) then
      return { TYPE = "String", Value = consumeString() }
    elseif isVarArg() then
      consume(2)
      return { TYPE = "VarArg" }
    elseif TOKENIZER_LUA_OPERATORS_LOOKUP[curChar] then
      return { TYPE = "Operator", Value = curChar }
    end

    return { TYPE = "Character", Value = curChar }
  end

  --// MAIN //--
  local function tokenize()
    local tokens = {}
    while curChar ~= "\0" do
      local token = getNextToken()
      if token then
        table.insert(tokens, token)
      end
      consume()
    end
    return tokens
  end

  return tokenize()
end

--/// Parser ///--
local PARSER_UNARY_OPERATOR_PRECEDENCE = 8
local PARSER_STOP_KEYWORDS       = createLookupTable({ "end", "else", "elseif", "until" })
local PARSER_OPERATOR_PRECEDENCE = { ["+"]   = {6, 6},  ["-"]  = {6, 6},
                                     ["*"]   = {7, 7},  ["/"]  = {7, 7}, ["%"] = {7, 7},
                                     ["^"]   = {10, 9}, [".."] = {5, 4},
                                     ["=="]  = {3, 3},  ["~="] = {3, 3},
                                     ["<"]   = {3, 3},  [">"]  = {3, 3}, ["<="] = {3, 3}, [">="] = {3, 3},
                                     ["and"] = {2, 2},  ["or"] = {1, 1} }
local PARSER_LUA_UNARY_OPERATORS  = createLookupTable({ "-", "#", "not" })
local PARSER_LUA_BINARY_OPERATORS = createLookupTable({ "+",  "-",   "*",  "/",
                                      "%",  "^",   "..", "==",
                                      "~=", "<",   ">",  "<=",
                                      ">=", "and", "or" })

--* Parser *--
local Parser = {}
function Parser.parse(tokens)
  local tokens            = tokens
  local currentToken      = tokens[1]
  local currentTokenIndex = 1
  local scopeStack        = {}
  local currentScope      = {}

  --// TOKEN NAVIGATION //--
  local function lookAhead(n)
    local updatedTokenIndex = currentTokenIndex + (n or 1)
    local updatedToken      = tokens[updatedTokenIndex]
    return updatedToken
  end
  local function consume(n)
    local updatedTokenIndex = currentTokenIndex + (n or 1)
    local updatedToken      = tokens[updatedTokenIndex]
    currentTokenIndex = updatedTokenIndex
    currentToken      = updatedToken
    return updatedToken
  end

  --// SCOPE MANAGEMENT //--
  local function pushScope()
    local scope = {
      localVariables = {}
    }
    table.insert(scopeStack, scope)
    currentScope = scope
    return scope
  end
  local function popScope()
    scopeStack[#scopeStack] = nil
    currentScope = scopeStack[#scopeStack]
  end

  --// IN-SCOPE VARIABLE MANAGEMENT //--
  local function declareLocalVariable(variable)
    currentScope.localVariables[variable] = true
  end
  local function declareLocalVariables(variables)
    for _, variable in ipairs(variables) do
      declareLocalVariable(variable)
    end
  end
  local function getVariableType(variableName)
    for scopeIndex = #scopeStack, 1, -1 do
      local scope = scopeStack[scopeIndex]
      if scope.localVariables[variableName] then
        return "Local", scopeIndex
      end
    end
    return "Global"
  end

  --// TOKEN CHECKERS //--
  local function checkToken(tokenType, tokenValue, token)
    local token = token or currentToken
    return token
          and token.TYPE  == tokenType
          and token.Value == tokenValue
  end
  local function isComma(token)
    return token and token.TYPE == "Character" and token.Value == ","
  end
  local function isUnaryOperator(token)
    return token and token.TYPE == "Operator" and PARSER_LUA_UNARY_OPERATORS[token.Value]
  end
  local function isBinaryOperator(token)
    return token and token.TYPE == "Operator" and PARSER_LUA_BINARY_OPERATORS[token.Value]
  end

  --// EXPECTORS //--
  local function expectCharacter(character, dontConsume)
    assert(currentToken and currentToken.TYPE == "Character", "Expected a character")
    assert(currentToken.Value == character, "Expected '" .. character .. "'")
    if not dontConsume then consume() end
  end
  local function expectKeyword(keyword, dontConsume)
    assert(currentToken and currentToken.TYPE == "Keyword", "Expected a keyword")
    assert(currentToken.Value == keyword, "Expected '" .. keyword .. "'")
    if not dontConsume then consume() end
  end

  --// PARSERS //--
  local consumeExpression, consumeExpressions
  local function consumeIdentifierList()
    local identifiers = {}
    while currentToken.TYPE == "Identifier" do
      table.insert(identifiers, currentToken.Value)
      if isComma(lookAhead()) then
        consume() -- Consume the comma
      else break end
    end
    return identifiers
  end
  local function consumeTableIndex(currentExpression)
    consume() -- Consume the "." symbol
    local indexToken = { TYPE = "String", Value = currentToken.Value }
    return { TYPE = "TableIndex", Index = indexToken, Expression = currentExpression }
  end
  local function parseFunctionCall(currentExpression)
    consume() -- Consume the "("
    local arguments = consumeExpressions()
    consume() -- Consume the last token of the expression
    return { TYPE = "FunctionCall", Expression = currentExpression, Arguments = arguments }
  end
  local function consumeOptionalSemilcolon()
    local nextToken = lookAhead()
    if checkToken("Character", ";", nextToken) then
      consume()
    end
  end

  --// EXPRESSSION PARSERS //--
  local parsePrimaryExpression, parseSuffixExpression,
        parsePrefixExpression,  parseUnaryOperator,
        parseBinaryExpression
  function parsePrimaryExpression()
    if not currentToken then return end
    local tokenType = currentToken.TYPE
    local tokenValue = currentToken.Value

    if tokenType == "Number" or tokenType == "String"
     or tokenType == "Constant" or tokenType == "VarArg" then
      return currentToken
    elseif tokenType == "Identifier" then
      local variableType = getVariableType(tokenValue)
      local variableNode = { TYPE = variableType, Value = tokenValue }
      return variableNode
    elseif tokenType == "Character" then
      if tokenValue == "(" then -- Parenthesized expression
        consume() -- Consume the parenthesis
        local expression = consumeExpression()
        consume() -- Consume the last token of the expression
        return expression
      end
    end
    return nil
  end
  function parseSuffixExpression(primaryExpression)
    local nextToken = lookAhead()
    local nextTokenValue = nextToken and nextToken.Value
    if nextTokenValue == "(" then -- Function call
      consume()
      -- <expression> \( <args> \)
      return parseFunctionCall(primaryExpression)
    elseif nextTokenValue == "." then -- Table access
      consume()
      -- <expression> \. <identifier>
      return consumeTableIndex(primaryExpression)
    end
    return nil
  end
  function parsePrefixExpression(precedence)
    local primaryExpression = parsePrimaryExpression(precedence) -- <primary>
    if not primaryExpression then return end

    -- <suffix>*
    while (true) do
      local newExpression = parseSuffixExpression(primaryExpression)
      if not newExpression then break end
      primaryExpression = newExpression
    end

    return primaryExpression
  end
  function parseUnaryOperator()
    -- <unary> ::= <unary operator> <unary> | <primary>
    if not isUnaryOperator(currentToken) then
      return parsePrefixExpression(UNARY_OPERATOR_PRECEDENCE)
    end

    -- <unary operator> <unary>
    consume() -- Consume the operator
    local expression = parseBinaryExpression(UNARY_OPERATOR_PRECEDENCE)
    return { TYPE = "UnaryOperator", Operator = unaryOperator.Value, Operand = expression }
  end
  function parseBinaryExpression(minPrecedence)
    -- <binary> ::= <unary> <binary operator> <binary> | <unary>
    local minPrecedence = minPrecedence or 0
    local expression = parseUnaryOperator() -- <unary>
    if not expression then return end

    -- [<binary operator> <binary>]
    while true do
      local operatorToken = lookAhead()
      local precedence = operatorToken and PARSER_OPERATOR_PRECEDENCE[operatorToken.Value]
      if not isBinaryOperator(operatorToken) or precedence[1] <= minPrecedence then
        break
      end

      -- The <binary operator> <binary> part itself
      local nextToken = consume(2) -- Advance to and consume the operator
      if not nextToken then error("Unexpected end") end

      local right = parseBinaryExpression(precedence[2])
      if not right then error("Unexpected end") end

      expression = { TYPE = "BinaryOperator",
        Operator = operatorToken.Value,
        Left = expression, Right = right }
    end
    return expression
  end
  function consumeExpression()
    local expression = parseBinaryExpression(0)
    if not expression then
      consume(-1)
      return
    end
    return { TYPE = "Expression", Value = expression }
  end
  function consumeExpressions()
    local expressions = { consumeExpression() }
    if #expressions == 0 then return {} end

    local nextToken = lookAhead()
    while isComma(nextToken) do
      consume(2) -- Consume the last token of the last expression and ","
      local expression = consumeExpression()
      table.insert(expressions, expression)
      nextToken = lookAhead()
    end

    return expressions
  end

  --// STATEMENT PARSERS //--
  local getNextNode, parseCodeBlock
  local function parseLocal()
    consume() -- Consume the "local" token
    local variables = consumeIdentifierList()
    declareLocalVariables(variables)
    consume() -- Consume the last token of the last identifier
    expectCharacter("=")
    local expressions = consumeExpressions()
    return { TYPE = "LocalDeclaration", Variables = variables, Expressions = expressions }
  end
  local function parseWhile()
    consume() -- Consume the "while" token
    local condition = consumeExpression()
    consume() -- Consume the last token of the condition
    expectKeyword("do")
    local codeblock = parseCodeBlock()
    expectKeyword("end", true)
    return { TYPE = "WhileLoop", Condition = condition, Codeblock = codeblock }
  end
  local function parseRepeat()
    consume() -- Consume the "repeat" token
    local codeblock = parseCodeBlock()
    expectKeyword("until")
    local condition = consumeExpression()
    return { TYPE = "RepeatLoop", Codeblock = codeblock, Condition = condition }
  end
  local function parseDo()
    consume() -- Consume the "do" token
    local codeblock = parseCodeBlock()
    expectKeyword("end", true)
    return { TYPE = "DoBlock", Codeblock = codeblock }
  end
  local function parseReturn()
    consume() -- Consume the "return" token
    local expressions = consumeExpressions()
    return { TYPE = "ReturnStatement", Expressions = expressions }
  end
  local function parseBreak()
    return { TYPE = "BreakStatement" }
  end
  local function parseIf()
    consume() -- Consume the "if" token
    local condition = consumeExpression()
    consume() -- Consume the last token of the condition
    expectKeyword("then")
    local codeblock = parseCodeBlock()
    local elseifs = {}
    while checkToken("Keyword", "elseif") do
      consume() -- Consume the "elseif" token
      local elseifCondition = consumeExpression()
      consume() -- Consume the last token of the condition
      expectKeyword("then")
      local elseifCodeblock = parseCodeBlock()
      table.insert(elseifs, { Condition = elseifCondition, Codeblock = elseifCodeblock })
    end
    local elseCodeblock
    if checkToken("Keyword", "else") then
      consume() -- Consume the "else" token
      elseCodeblock = parseCodeBlock()
    end
    expectKeyword("end", true)
    return { TYPE = "IfStatement", Condition = condition, Codeblock = codeblock, ElseIfs = elseifs, ElseCodeblock = elseCodeblock }
  end

  --// CODE BLOCK PARSERS //--
  function getNextNode()
    local currentTokenValue = currentToken.Value
    local currentTokenType = currentToken.TYPE
    if currentTokenType == "Keyword" then
      local node
      if PARSER_STOP_KEYWORDS[currentTokenValue] then return
      elseif currentTokenValue == "local"        then node = parseLocal()
      elseif currentTokenValue == "while"        then node = parseWhile()
      elseif currentTokenValue == "repeat"       then node = parseRepeat()
      elseif currentTokenValue == "do"           then node = parseDo()
      elseif currentTokenValue == "return"       then node = parseReturn()
      elseif currentTokenValue == "break"        then node = parseBreak()
      elseif currentTokenValue == "if"           then node = parseIf()
      else error("Unsupported keyword: " .. currentTokenValue) end
      consumeOptionalSemilcolon()
      return node
    end

    local expression = consumeExpression()
    consumeOptionalSemilcolon()
    return expression.Value
  end
  function parseCodeBlock()
    pushScope()
    local nodeList = { TYPE = "Group" }
    while currentToken do
      local node = getNextNode()
      if not node then break end
      table.insert(nodeList, node)
      consume()
    end
    popScope()
    return nodeList
  end

  --// MAIN //--
  local function parse()
    local ast = parseCodeBlock()
    ast.TYPE = "AST"
    return ast
  end

  return parse()
end

--// Compiler //--
local MODE_iABC = 0
local MODE_iABx = 1
local MODE_iAsBx = 2

local opcodeToNumberLookup = {
  ["MOVE"]     = 0,  ["LOADK"]     = 1,  ["LOADBOOL"] = 2,  ["LOADNIL"]   = 3,
  ["GETUPVAL"] = 4,  ["GETGLOBAL"] = 5,  ["GETTABLE"] = 6,  ["SETGLOBAL"] = 7,
  ["SETUPVAL"] = 8,  ["SETTABLE"]  = 9,  ["NEWTABLE"] = 10, ["SELF"]      = 11,
  ["ADD"]      = 12, ["SUB"]       = 13, ["MUL"]      = 14, ["DIV"]       = 15,
  ["MOD"]      = 16, ["POW"]       = 17, ["UNM"]      = 18, ["NOT"]       = 19,
  ["LEN"]      = 20, ["CONCAT"]    = 21, ["JMP"]      = 22, ["EQ"]        = 23,
  ["LT"]       = 24, ["LE"]        = 25, ["TEST"]     = 26, ["TESTSET"]   = 27,
  ["CALL"]     = 28, ["TAILCALL"]  = 29, ["RETURN"]   = 30, ["FORLOOP"]   = 31,
  ["FORPREP"]  = 32, ["TFORLOOP"]  = 33, ["SETLIST"]  = 34, ["CLOSE"]     = 35,
  ["CLOSURE"]  = 36, ["VARARG"]    = 37
}
local opmodes = {
  [0] = MODE_iABC,  [1]  = MODE_iABx,  [2]  = MODE_iABC,
  [3] = MODE_iABC,  [4]  = MODE_iABC,  [5]  = MODE_iABx,
  [6] = MODE_iABC,  [7]  = MODE_iABx,  [8]  = MODE_iABC,
  [9] = MODE_iABC,  [10] = MODE_iABC,  [11] = MODE_iABC,
  [12] = MODE_iABC, [13] = MODE_iABC,  [14] = MODE_iABC,
  [15] = MODE_iABC, [16] = MODE_iABC,  [17] = MODE_iABC,
  [18] = MODE_iABC, [19] = MODE_iABC,  [20] = MODE_iABC,
  [21] = MODE_iABC, [22] = MODE_iAsBx, [23] = MODE_iABC,
  [24] = MODE_iABC, [25] = MODE_iABC,  [26] = MODE_iABC,
  [27] = MODE_iABC, [28] = MODE_iABC,  [29] = MODE_iABC,
  [30] = MODE_iABC, [31] = MODE_iAsBx, [32] = MODE_iAsBx,
  [33] = MODE_iABC, [34] = MODE_iABC,  [35] = MODE_iABC,
  [36] = MODE_iABx, [37] = MODE_iABC
}

--* Compiler *--
local Compiler = {}
function Compiler.compile(ast)
  local locals = {}
  local takenRegisters = {}
  local code = {}
  local constants = {}
  local constantLookup = {}

  --// REGISTER MANAGEMENT //--
  local function allocateRegister()
    for i = 0, 255 do
      if not takenRegisters[i] then
        takenRegisters[i] = true
        return i
      end
    end
    error("Out of registers")
  end
  local function deallocateRegister(register)
    takenRegisters[register] = nil
  end
  local function deallocateRegisters(registers)
    for _, register in ipairs(registers) do
      takenRegisters[register] = nil
    end
  end

  --// UTILITY FUNCTIONS //--
  local function findOrCreateConstant(value)
    if constantLookup[value] then
      return constantLookup[value]
    end
    table.insert(constants, value)
    local constantIndex = -(#constants)
    constantLookup[value] = constantIndex
    return constantIndex
  end
  local function addInstruction(opname, a, b, c)
    local instruction = { opname, a, b, c }
    table.insert(code, instruction)
    return instruction
  end
  local function registerVariable(localName, register)
    locals[localName] = register
  end

  --// CODE GENERATION //--
  local function processExpressionNode(node, expressionRegister)
    local expressionRegister = expressionRegister or allocateRegister()
    local nodeType = node.TYPE
    while nodeType == "Expression" do
      node = node.Value
      nodeType = node.TYPE
    end

    if nodeType == "Number" then
      addInstruction("LOADK", expressionRegister, findOrCreateConstant(tonumber(node.Value)))
    elseif nodeType == "Global" then
      addInstruction("GETGLOBAL", expressionRegister, findOrCreateConstant(node.Value))
    elseif nodeType == "Local" then
      addInstruction("MOVE", expressionRegister, locals[node.Value])
    elseif nodeType == "String" then
      addInstruction("LOADK", expressionRegister, findOrCreateConstant(node.Value))
    else
      error("Unsupported expression node type: " .. tostring(nodeType))
    end

    return expressionRegister
  end
  local function processStatementNode(node)
    local nodeType = node.TYPE
    if nodeType == "FunctionCall" then
      local expressionRegister = processExpressionNode(node.Expression)
      local argumentRegisters = {}
      for _, argument in ipairs(node.Arguments) do
        local argumentRegister = processExpressionNode(argument)
        table.insert(argumentRegisters, argumentRegister)
        deallocateRegister(argumentRegister)
      end
      addInstruction("CALL", expressionRegister, #node.Arguments + 1, 1)
      deallocateRegister(expressionRegister)
      deallocateRegisters(argumentRegisters)
    elseif nodeType == "LocalDeclaration" then
      local expressionRegisters = {}
      for index, expression in ipairs(node.Expressions) do
        local expressionRegister = processExpressionNode(expression)
        table.insert(expressionRegisters, expressionRegister)
        if not node.Variables[index] then
          -- If this expression doesn't have a corresponding variable, deallocate it
          deallocateRegister(expressionRegister)
        end
      end
      for index, localName in ipairs(node.Variables) do
        local expressionRegister = expressionRegisters[index]
        if not expressionRegister then
          -- Load nil into the register
          expressionRegister = allocateRegister()
          addInstruction("LOADNIL", expressionRegister, expressionRegister)
        end
        registerVariable(localName, expressionRegister)
      end
    else
      error("Unsupported statement node type: " .. tostring(nodeType))
    end
  end
  local function processCodeBlock(list)
    for index, node in ipairs(list) do
      processStatementNode(node)
    end
  end
  local function processAST(ast)
    processCodeBlock(ast)
    addInstruction("RETURN", 0, 1, 0)
  end

  --// Bitwise operations (needed for compiling to bytecode) //--
  local function bitNot(value)
    local p,c=1,0
    while value > 0 do
        local r=value%2
        if r<1 then c=c+p end
        value,p=(value-r)/2, p*2
    end
    return c
  end
  local function bitXor(m, n)
    local xr = 0
    for p=0,31 do
        local a = m / 2 + xr
        local b = n / 2
        if (a ~= math.floor(a)) and (b ~= math.floor(b)) then
            xr = math.pow(2, p)
        else
            xr = 0
        end
        m, n = math.floor(a), math.floor(b)
    end
    return xr
  end
  local function twosComplement(value, bits)
    if value < 0 then
      value = value + 1
      if value < 0 then
        value = bitXor(bitNot(math.abs(value)), math.pow(2, bits) - 1) + 1
      end
    end
    return value
  end
    local function makeOneByte(value)
    return string.char(value)
  end
  local function makeTwoBytes(value)
    local byte1 = value % 256
    value = math.floor(value / 256)
    local byte2 = value % 256
    return string.char(byte1) .. string.char(byte2)
  end
  local function makeFourBytes(value)
    local byte1 = value % 256
    value = math.floor(value / 256)
    local byte2 = value % 256
    value = math.floor(value / 256)
    local byte3 = value % 256
    value = math.floor(value / 256)
    local byte4 = value % 256
    return string.char(byte1) .. string.char(byte2)
        .. string.char(byte3) .. string.char(byte4)
  end
  local function makeEightBytes(value)
    local byte1 = value % 256
    value = math.floor(value / 256)
    local byte2 = value % 256
    value = math.floor(value / 256)
    local byte3 = value % 256
    value = math.floor(value / 256)
    local byte4 = value % 256
    value = math.floor(value / 256)
    local byte5 = value % 256
    value = math.floor(value / 256)
    local byte6 = value % 256
    value = math.floor(value / 256)
    local byte7 = value % 256
    value = math.floor(value / 256)
    local byte8 = value % 256
    return string.char(byte1) .. string.char(byte2)
        .. string.char(byte3) .. string.char(byte4)
        .. string.char(byte5) .. string.char(byte6)
        .. string.char(byte7) .. string.char(byte8)
  end
  local function makeDouble(value)
    local sign = value < 0 and 1 or 0
    local value = math.abs(value)

    local mantissa, exponent = math.frexp(value)
    if value == 0 then -- zero
      mantissa, exponent = 0, 0
    elseif value == 1/0 then -- infinity
      mantissa, exponent = 0, 2047
    else
      mantissa = (mantissa * 2 - 1) * math.ldexp(0.5, 53)
      exponent = exponent + 1022
    end

    -- 52-bit mantissa
    local double = {}
    for i = 1, 6 do
      table.insert(double, mantissa % 256)
      mantissa = math.floor(mantissa / 256)
    end

    -- exponent (11 bit)
    table.insert(double, ((mantissa % 16) + (exponent % 2^4) * 16) % 256)
    exponent = math.floor(exponent / 2^4)
    table.insert(double, ((sign * 128) + exponent) % 256)

    return string.char(unpack(double))
  end
  local function makeString(value)
    local value = value .. "\0"
    local size = makeEightBytes(#value)
    return size .. value
  end
  local function makeConstant(constantValue, constantType)
    if constantType == "number" then
      return makeOneByte(3) .. makeDouble(constantValue)
    elseif constantType == "string" then
      return makeOneByte(4) .. makeString(constantValue)
    elseif constantType == "boolean" then
      local secondByte = (constantValue and 1) or 0
      return makeOneByte(1) .. makeOneByte(secondByte)
    elseif constantType == "nil" then
      return makeOneByte(0)
    else
      error("Unsupported constant type: " .. constantType)
    end
  end
  local function makeInstruction(instruction)
    local opcode = opcodeToNumberLookup[instruction[1]]
    local a = twosComplement(instruction[2] or 0, 9)
    local b = twosComplement(instruction[3] or 0, 9)
    local c = twosComplement(instruction[4] or 0, 9)
    local opmode = opmodes[opcode]
    local mode = opmode
    local instruction = 0
    if opmode == MODE_iABC then
      instruction = instruction + opcode
      instruction = instruction + (a * 64)      -- a << 6
      instruction = instruction + (b * 8388608) -- b << 23
      instruction = instruction + (c * 16384)   -- c << 14
    elseif opmode == MODE_iABx then
      instruction = instruction + opcode
      instruction = instruction + (a * 64)        -- a << 6
      instruction = instruction + (b * 16384)     -- b << 14
    elseif opmode == MODE_iAsBx then
      instruction = instruction + opcode
      instruction = instruction + (a * 64)               -- a << 6
      instruction = instruction + ((b + 131071) * 16384) -- (b + 131071) << 14
    elseif opmode == MODE_iAB then
      instruction = instruction + opcode
      instruction = instruction + (a * 64)    -- a << 6
      instruction = instruction + (b * 16384) -- b << 14
    end
    return makeFourBytes(instruction)
  end

  local function makeConstantSection()
    local constantSection = makeFourBytes(#constants) -- Number of constants
    for _, constant in ipairs(constants) do
      local constantType = type(constant)
      constantSection = constantSection .. makeConstant(constant, constantType)
    end
    constantSection = constantSection .. makeFourBytes(0) -- Number of functions
    return constantSection
  end
  local function makeCodeSection()
    local codeSection = makeFourBytes(#code) -- Number of instructions
    for _, instruction in ipairs(code) do
      codeSection = codeSection .. makeInstruction(instruction)
    end
    return codeSection
  end

  local function makeFunction()
    local functionHeader = makeString("@test.lua") -- Function name
    functionHeader = functionHeader .. makeFourBytes(0) -- Line defined
    functionHeader = functionHeader .. makeFourBytes(0) -- Last line defined
    functionHeader = functionHeader .. makeOneByte(0) -- nups (Number of upvalues)
    functionHeader = functionHeader .. makeOneByte(0) -- Number of parameters
    functionHeader = functionHeader .. makeOneByte(2) -- Is vararg (2 = VARARG_HASARG)
    functionHeader = functionHeader .. makeOneByte(5) -- Max stack size

    functionHeader = functionHeader .. makeCodeSection()
    functionHeader = functionHeader .. makeConstantSection()

    functionHeader = functionHeader .. makeFourBytes(0) -- Line info
    functionHeader = functionHeader .. makeFourBytes(0) -- Local variables
    functionHeader = functionHeader .. makeFourBytes(0) -- Upvalues
    return functionHeader
  end
  local function makeHeader()
    local header = "\27Lua" -- Signature
    header = header .. string.char(0x51)  -- Version 5.1
    header = header .. "\0"  -- Format 0 (official)
    header = header .. "\1"  -- Little endian
    header = header .. "\4"  -- sizeof(int)
    header = header .. "\8"  -- sizeof(size_t)
    header = header .. "\4"  -- sizeof(Instruction)
    header = header .. "\8"  -- sizeof(lua_Number)
    header = header .. "\0"  -- Integral flag
    return header
  end

  local function makeBytecode()
    local header = makeHeader()
    local functionHeader = makeFunction()
    return header .. functionHeader
  end

  --// MAIN //--
  local function compile()
    processAST(ast)
    return makeBytecode()
  end

  return compile()
end

return {
  Tokenizer = Tokenizer,
  Parser = Parser,
  Compiler = Compiler
}